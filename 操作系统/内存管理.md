# 内存管理

## 存储(内存)管理概述

存储管理要求

- 重定位
  - memory 换出到Disk中，Disk换进memory，程序地址会上下浮动。如果程序中有跳转地址时，需要更新地址内容
- 保护
- 共享
- 逻辑组织
- 物理组织

## 程序的装入和链接

用户源程序编程一个可在内存中的程序，通常要经过3步

1. 编译：由编译程序(Compiler)将用户源代码编译成若干个目标模块
   1. 词法分析(检查关键字等)
   2. 语法分析
   3. 语义分析
   4. 中间代码
   5. 目标代码
2. 链接：有链接程序(linker)将编译后形成的一组目标模块，以及所需要的库函数链接在一起，形成一个完整的装入模块
3. 装入：由装入程序(loader)将装入模块装入内存

链接和装入 P219

![链接和加载场景](内存管理.assets/链接和加载场景.png)

### 装入

装入方式：绝对装入方式、重定位装入，运行时装入

#### 绝对装入方式

- 如果知道程序将驻留在内存的什么位置，那么，**编译程序**将产生绝对地址的目标代码，如BIOS和底层驱动等
- **绝对装入程序**按照装入模块中的地址，将程序和数据装入内存。装入模块被装入内存后，由于程序中的<u>逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改</u>
- 为了便于程序的修改,对编译的程序采用符号地址，然后在编译或汇编时，再将这些符号地址转换为绝对地址

#### 可重定位装入

- 目标模块的起始地址通常是从0开始的，程序中的其它地址也都是相对于起始地址计算的
- 由装入程序将装入模块装入内存后，装入模块中程序所访问的所有逻辑地址与实际装入内存的物理地址不同 ，必须进行变换

把在装入时对目标程序中指令和数据的变换过程称为重定位。因为地址变换是在装入时一次完成的，地址在装入时进行计算，以后不再改变，故称为静态重定位

假设：有程序A 0~1FFH，大小 200H。memory中装入起始地址300H。程序中有一条请求2FFH的请求，就会变成5FFH。

 采用静态重定位方法将程序装入内存,称为可重定位装入方式

#### 运行时装入

采用动态重定位方式将程序装入内存

### 链接

链接器的功能是把一组目标模块作为输入，产生一个包含完整程序和数据模块的加载模块

#### 静态链接

链接之后整个模块不再做变化，装入时模块一次性全部装入(作为一个整体)

![链接功能](内存管理.assets/链接功能.png)

#### 装入时动态链接

装入内存时，边装入边链接

优点：

- 便于修改和更新
- 便于实现对目标模块的共享
  - 如果采取静态链接，每个模块必须含有目标模块的拷贝

#### 运行时动态链接

在执行中需要目标模块四，由OS去找到该模块并装入内存...

可以查看附录7

## 连续分配

分配方式：连续分配和离散分配（现代操作系统大多用离散分配，页和段）

### 连续分配方式

指一个用户程序分配一个连续的内存空间，连续分配方式有四种

1. 单一连续分配
2. 固定分区分配
3. 动态分区分配
4. 可重定位分区分配

#### 单一连续分配

单用户单任务系统

把内存分为系统区和用户区两部分

1. 系统区仅提供给OS使用，通常是放在内存的低址部分
2. 用户区是指除系统区以外的...

#### 固定分区分配

将用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业

划分分区的方法：

- 分区大小相等：当程序太小是，会造成内存空间的浪费。当程序太大是，<u>一个分区有不足以装入程序，使该程序无法运行</u>
- 分区大小不等：把内存划含有多个较小的分区、适量的中等分区及少量的大分区

因为一个分区只装一个进程，内零头：分区内无法利用的空的空间

#### 动态分区分配

根据进程的实际需要，动态地为之分配内存空间

外零头（外部碎片）：若干不可利用的小分区

### 适配方法

- 最佳适配：空闲空间与要求的最接近的分区块
  - 优缺点
- 为大作业分配大的内存空间创造了条件
  - 每次分配后所切割下来的剩余部分总是最小的，在存储器中会留下许多难以利用的小空闲区。会剩下很多的外零头
  
- 最差适配：空闲空间与请求空间最不接近的分区块
- 首次适配：从头到尾找一个适合的（只要能装下）
- 下次适配，接着上次的位置往后找

空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况

空闲分区链：为了实现对空闲分区的分配和链接，设置前向指针和后向指针，通过前、后向链接指针将所有的空闲分区链接成一个双向链。下一个可以分区的信息

紧凑：将用户程序间外零头消除，排到一起，可重定位的动态分区分配

可重定位分区分配：采用动态重定位技术的分区分配

```mermaid
graph TB
a(请求分配u.size分区) --> b[检索空闲分区链/表 ]
b--> c{找到大于u.sized的可用区}
c-->|否|d{空闲分区总和>=u.size?}
d-->|否|e(无法分配返回)
d-->|是|e2[进行紧凑形成连续空闲区]
e2-->e3[修改有关的数据结构]
c-->d1[按动态分配方式进行分配]
e3-->d1
d1-->d2[修改有关的数据结构]
d2-->f(返回分区号及首批)
```

### 伙伴系统实现

伙伴系统是一种不需要紧凑的动态分区算法

伙伴系统是内存块管理机制，采用二进制数的方式来分配和回收空间

伙伴系统实现方式：假设整个内存的大小为2U 。在伙伴系统中，系统初始启动时整个内存将被视作单一的空闲分区。如果进程请求的尺寸s在 2U-1 < s <= 2U 之间，则全部分给进程，否则一分为二，再继续比较，直到满足需要的最小者为止。

![伙伴系统实现](内存管理.assets/伙伴系统实现.png)

100K接近128K，二分(512,256,128,128)到128，并分配一块

和伙伴空白空间合并（临近且大小一致的空白）

### Linux内存管理

Linux采用多种内存分配策略，2.4版采用伙伴系统：

- 把内存划分为块组，大小为2的幂次，如1页=20、2页=21、4页=22、8页=23等。
- 将相同大小的组织成一个队列。并用位示图表示占用与否。
- 将多个队列组织成一个表。

![Linux内存管理结构](内存管理.assets/Linux内存管理结构.png)

## 离散分配

### 离散分配方式

离散分配:为进程分配的空间不要求是连续的,可以是多个分离的空间

采用离散分配方式的存储管理有

- 分页存储管理
- 段式存储管理
- 段页式存储管理

### 分页存储管理

基本思想

- 页面或页（Page）：将一个**进程的逻辑**地址空间分成若干个大小相等的片
- （**物理**）块（Block）或页框（Frame）：把**内存空间**分成与页面相同大小的若干个存储块
- 在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中
- 在分页存储管理方式中，把每个作业**全部装入**内存后方能运行，则称为基本的分页存储管理方式，或称为纯分页存储管理方式
- 纯分页存储管理方式不具有支持实现虚拟存储器的功能

#### 页面大小

如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择得适中，且页面大小应是2的幂，通常为512B～8KB

空间的组织

- 地址空间[^1]为程序限定的空间
- 物理空间为内存限定空间
- 在页式管理系统中将地址空间分成大小相同页面。将内存空间分成与页面相同大小的存储块
- 分页的地址结构

页号P | 位移量w

#### 页表

页表：页号有块号之间的映射关系

<u>系统又为每个进程建立了一张页面映像表</u>，在分页系统中，允许将进程的每一页离散地存储在内存的任一物理块中，但系统应能保证进程的正确运行，即能在内存中找到每个页面所对应的物理块

在页表的表项中设置一存取控制字段，用于对该存储块中的内容加以保护，如读写权限等

例子：进程5M,Page.size=2K 页表项32bit=4B

$$
页表长度=\frac{进程大小}{页大小}=\frac{5\times2^{20}}{2\times2^{10}}=5\times2^{9}\\页表大小=5\times2^{9}\times2^2B=5\times2^{11}B=10KB
$$
例：进程28K，page.size=8K，Call [14520]_10，求页号和偏移量:star2:
$$
{14520}\div{8\times2^{10}}=1\dots6328\\每块8K，对应实际地址前面共3块\\偏移量:3\times8K+6328=30904
$$

#### 地址变换机构

为了能将用户地址空间中的逻辑地址，变换为内存空间中的物理地址，在系统中必须设置地址变换机构。该机构的基本任务是实现从逻辑地址到物理地址的转换。

基本的地址变换机构

页表大多驻留在内存中。在系统中只设置一个页表寄存器PTR，在其中存放页表在内存的始址和页表的长度

![地址变换机构示意图](内存管理.assets/地址变换机构示意图.png)

##### 例子

考虑一个简单分页系统，物理存储器大小为4GB,页大小为1KB,逻辑地址空间分为2^16个页

- 逻辑地址空间包含多少位？
- 一个帧中包含多少字节？1KB
- 物理地址中指定一个帧需要多少位？
- 页表中包含多少个页表项？2^16
- 每个页表项包含多少位？ 
  - 页表项存的是 页号和块号的对应关系
  - 页表中页号是由页表项宽度计算得到，并不存储
  - 页表中存储块号和标志位

页大小1KB 偏移量10bit表示；物理存储4GB，所以有2^22个物理块，需要22bit表示物理块；分成2^16页号，页号16位。

16bit页号 | 10bit偏移量

#### 快表

为了提高地址变换速度，可在地址变换机构中，增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”（Associative Memory）或称为“快表”Cache

快表不可能做得很大，通常只存放16～512个页表项。

![具有快表的地址变换过程](内存管理.assets/具有快表的地址变换过程.png)

Cache中存储的是最近经常命中的页表项

#### 多级页表

现代大多数计算机系统

- 采用离散分配方式来解决难以找到一块连续的大内存空间的问题
- 只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入

二级页表

将页表再进行分页，并离散地将各个页面分别存放在不同的物理块中 ，为**离散分配**的页面再建立一张页表，称为**外层页表** ，在每个页表项中记录了页表页面的物理块号。

离散分配节省了内存空间，将不需要的页表可以放在内存中

例子：若在32位的地址空间时，采用页面大小为4K占12位，一级页表结构，应具有20位的页号，即页表项应有1兆个。在采用两级页表结构时，逻辑地址结构可描述如下： 

![二级页表结构](内存管理.assets/二级页表结构.png)

两级页表地址变换的实现：

为了地址变换实现上的方便起见，在地址变换机构中同样需要增设一个外层页表寄存器，用于存放外层页表的始址，并利用逻辑地址中的外层页号，作为外层页表的索引，从中找到指定页表分页的始址，再利用P2作为指定页表分页的索引，找到指定的页表项，其中即含有该页在内存的物理块号，用该块号和页内地址d即可构成访问的内存物理地址。

![二级页表地址变换](内存管理.assets/二级页表地址变换.png)

外部页表的里面存的是块号，这个块号是页表的号码





---

[^1]:进程能够访问的内存地址的集合

如32bit地址线可以访问2^32的地址空间