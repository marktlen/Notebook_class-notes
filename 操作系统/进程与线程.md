# 进程和线程 Processes and Threads

## 自己动手引导计算机启动

所需软件

- Virtual Box, VMware等虚拟机软件
- Ubuntu，RedHat等Linux发行版
- Windows
- Linux下的汇编编译器nasm
- 程序源文件编辑器
- Internet

```assembly
	org	07c00h			; 告诉编译器程序加载到7c00处
	mov	ax, cs
	mov	ds, ax
	mov	es, ax
	call	DispStr			; 调用显示字符串例程
	jmp	$			; 无限循环
DispStr:
	mov	ax, BootMessage
	mov	bp, ax			; ES:BP = 串地址
	mov	cx, 16			; CX = 串长度
	mov	ax, 01301h		; AH = 13,  AL = 01h
	mov	bx, 000ch		; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮)
	mov	dl, 0
	int	10h			; 10h 号中断
	ret
BootMessage:		
	db	"Hello, OS world!"
	times 	510-($-$$)	db	0; 填充剩下的空间，使生成的二进制代码恰好为512字节
	dw 	0xaa55				; 结束标志

```

1. 编写汇编程序

2. https://blog.csdn.net/judyge/article/details/52278384

3. 用nasm编译上述汇编程序

   nasm boot.asm - o boot.bin

   提示:需要先安装nasm工具，在Ubuntu环境下，使用： sudo apt-get install nasm即可

4. 将bin文件转换成可启动的映像文件

   ```bash
   $dd if=boot.bin of=boot.img bs=512 count=1
   1+0 records in
   1+0 records out
   512 bytes copied, 0.000222849 s, 2.3 MB/s
   $dd if=/dev/zero of=boot.img skip=1 seek=1 bs=512 count=2879
   2879+0 records in
   2879+0 records out
   1474048 bytes (1.5 MB, 1.4 MiB) copied, 0.0214993 s, 68.6 MB/s
   ```

5. 将生成的img文件拷贝出来用于启动虚拟机

   sudo mkdir /mnt/share

   sudo mount - t vboxsf Kanbox /mnt/share

   前提：安装virtualBox的附件

6. 新建虚拟机，用img文件启动

## 进程 process

进程是操作系统最核心的概念

现代操作系统的一切都为进程而展开

进程是**正在运行的程序的一个抽象（正解）**

- 进程执行模型
  - 顺序执行（Sequential Mode）
  - 并发执行（Parallel Mode）

- 伪并行
  - 并行与并发

## 进程的执行模型

对应到操作系统当中，进程的执行模型同样有**顺序执行**和**并行执行**。

顺序执行：一个进程执行完毕，再紧接着执行另外一个进程

![One program counter](img\One program counter.png)

缺点：执行效率太低

并行执行：四个进程同时执行，相互独立，互不干扰

![Four program Counters](img\Four program Counters.png)

缺点：硬件要求太高

### 进程的并发执行模型

**并发(concurrence)执行是微观上的顺序执行，宏观上的并行执行**

 并发

![进程并发执行模型示意图](img\进程并发执行模型示意图.png)

有两个程序A和B共享一个变量N，初始值为5

A A1:N=N+1

B B1: Print(N)

    B2: N=0;

不同的执行顺序，会产生不一样的结果

## 进程的状态

![两状态进程模式图](img\两状态进程模式图.png)

进程的三种基本状态

- **就绪（Ready）状态**：当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。

- **执行状态（Running）**：进程已获得CPU，其程序正在执行。

- **阻塞状态（Blocked）**：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，把这种暂停状态称为阻塞状态，有时也称为等待状态。

````mermaid
graph RL
a((就绪)) --进程调度--> b((执行))
b --请求资源--> c((阻塞))
c --请求得到满足--> a
b --时间片用完-->a
````

单阻塞队列

![单阻塞队列](img\单阻塞队列.png)

多阻塞队列

![多阻塞队列](img\多阻塞队列.png)

多阻塞队列可以分类请求，分别处理，只需要检测CPU请求的队列

New：进程已经创建，但未被OS接纳为可执行进程，并且程序还在辅存，PCB在内存

Exit：因停止或取消，被OS从执行状态释放

```mermaid
graph LR
a(New) --Admit--> b(Ready)
b --Dispatch--> c(Running)
c --Release--> d(Exit)
c --Event Walt--> e(Blocked)
e --Event Occurs--> b
c --Timeout--> b
```

### 进程的挂起状态

挂起状态：使执行的进程暂停执行,静止下来,我们把这种静止状态称为挂起状态。

| 事件           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 交换           | 操作系统需要释放足够的内存空间，以调入并执行处于就绪状态的进程 |
| 其他OS原因     | 操作系统可能挂起后台进程或工具程序进程，或者被怀疑导致问题的进程 |
| 交互式用户请求 | 用户可能希望挂起一个程序的执行，目的是为了调试或者与一个资源的使用和连接 |
| 定时           | 一个进程可能会周期性地执行（例如记账或系统监视进程），而且可能等待下个时间间隔时挂起 |
| 父进程请求     | 父进程可能会希望挂起后代进程的执行，一检查或修改挂起的进程，或者协调不同后代进程之间的行为 |

引入了挂起状态

![含有挂起态的进程状态转换图](img\含有挂起态的进程状态转换图.png)

- 空白→新建：系统调用、用户登陆、用户请求……
- 新建→就绪：系统尚有空余资源，接纳进程并放入就绪队列

- 就绪→运行：获得了除了CPU之外的所有资源

- 运行→完毕：进程正常执行完毕或者被KILL

- 运行→就绪：时间片用完、CPU被抢占

- 运行→阻塞：等待请求完成

- 阻塞→就绪：请求已经完成

- 就绪（阻塞）→退出：无偿地被KILL

- 阻塞→阻塞挂起：释放内存空间

- 就绪→就绪挂起：没有阻塞进程，挂起就绪进程以释放空间

- 就绪挂起→就绪：没有就绪进程或者就绪进程优先级较低

- 阻塞挂起→阻塞

- 阻塞挂起→就绪挂起

## 进程的控制

- 进程状态（若干状态之间的转换及转换依据）

- 进程映像
  - 进程的程序、数据、堆、栈的集合

- 进程控制块 PCB （Process Control Block）
  - 用于控制进程属性的集合

- 进程图

![General Structure of operating system control tables](img\操作系统控制表的一般结构.png)

primary process table中就是进程映像，Process Image中的进程也会和其他tables有交互

**进程控制块**

| PCB存储信息 | 内容和功能（p87)                                  |
| ----------- | ------------------------------------------------- |
| 标识符      | PID和进程名称（名称会重复） Win:>tasklist可以查看 |
| 状态        |                                                   |
| 优先级      |                                                   |
| 程序计数器  | 下一条执行指令的地址                              |
| 内存指针    | 程序代码和进程相关数据指针、共享内存块指针等      |
| 上下文      | 处理器的寄存器数据信息                            |
| IO状态      | 处理器的使用时间总和、时间限制等，设备状态        |
| 审计信息    | 执行时间，使用资源。供操作系统参考和参考          |

进程标识

- 标识符

处理器状态信息

- 用户可见寄存器，控制和状态寄存器，栈指针

进程控制信息

- 调度和状态信息，进程间通信，特权、存储管理、资源使用情况

![进程的组成](img\进程的组成.png)

- 操作系统维持着一个由PCB组成的链表，根据链表中的PCB来控制系统中的进程
- 进程控制块面临的难题——安全保护
  - 病毒会不出现在PCB中，或修改其他进程

**进程图 Process Graph**

进程图是用于描述一个进程的家族关系的有向树。

**子进程**可以继承**父进程**所拥有的资源。

当子进程被撤消时，应将其从父进程那里获得的资源归还给父进程。 

思考：父进程死掉，子进程怎么办？

#### 进程的创建 Process Creation

Events which cause process creation:

- 系统初始化 System initialization.

- 正在运行的进程调用了一个进程创建系统

  Execution of a process creation system call by a running process.

- 用户请求 A user request to create a new process.

- 批处理作业的初始化 Initiation of a batch job.

分配一个唯一进程标识符，分配相应空间（包括进程映像所以元素）

调用进程**创建原语**按下述步骤创建一个新进程：

1. 申请空白PCB。  

2. 为新进程分配资源。为新进程的程序和数据以及用户栈分配必要的内存空间。

3. 初始化进程控制块。
   - 初始化标识信息。
   - 初始化处理机状态信息。使程序计数器指向程序的入口地址，使栈指针指向栈顶；
   - 初始化处理机控制信息：进程的状态、优先级。

4. 将新进程插入就绪队列。

关于Unix和Windows的不同做法

- Unix：fork()

- 创建一个和调用进程相同的副本。
  - 相同的存储映像、相同的环境……

- 子进程执行execve修改存储映像

#### 进程终止 Process Termination

Events which cause process termination:

- Normal exit (voluntary).

- Error exit (voluntary).

- Fatal error (involuntary).

- Killed by another process (involuntary).

利用**终止原语**(原子操作，不可再分)终止进程

- 检索将被终止的进程PCB

- 终止该进程的执行（若有子进程，一并终止）

- 回收资源

- 将该进程PCB从当前队列中移除

#### 进程的阻塞

调用**阻塞原语**自我阻塞

自我阻塞，所以阻塞是发生在运行过程中。会插入到不同的阻塞队列中

- 暂停进程的执行，修改PCB运行状态

- 将PCB插入阻塞队列

- 调度新进程

#### 进程的唤醒

调用**唤醒原语**唤醒进程

- 检索阻塞队列，寻找要唤醒进程的PCB

- 修改PCB的运行状态

- 插入PCB到就绪队列

#### 进程的挂起与激活

利用**挂起原语**挂起进程

利用**激活原语**激活进程

### 进程的切换

步骤

- 保存处理器状态信息

- 更新当前进程的状态

- 将当前进程PCB移动到相应的队列

- 选择另一个进程PCB

- 更新该进程的PCB

- 更新内存管理的数据结构

- 恢复当前进程被切换前的上下文信息

### 模式切换

模式切换可以不改变正处于运行态的进程的状态。

	进程切换会导致模式切换，反之不一定改变
	
	如：使用内心功能，进程发出系统调用请求，进程一直处于执行状态；当系统调用为IO处理时，进程状态会变成阻塞状态

保存上下文环境和恢复上下文环境只需要很小的开销

## 线程 Threads

回顾进程的概念

- 每个进程有自己独立的地址空间

- 每个进程拥有自己资源的控制权
  - I/O、主存、文件……
- 进程是操作系统的最小调度单位
  - 进程切换

为了减少操作系统的开销，现代操作系统引入线程的概念

线程是调度的最小单位

进程是资源拥有的最小单位

一个进程可以有多个线程

组合方式：单进程单线程	单进程多线程	多进程单线程	多线程多进程

线程的特点

- 同一个进程的所有线程共享该进程的资源

- 同一个进程的所有线程共享同一个地址空间

线程的优点

- 创建快（比进程大约快10倍）（在进程的资源基础上创建）

- 终止快（线程终止不需要被回收）

- 切换快（一般在进程内部切换，保存信息较少）

- 通信快，无需内核介入

![线程进程模型](img\线程进程模型.png)

在支持线程的操作系统中，线程是调度分派的最小单位，进程是资源拥有的最小单位

线程同样具有几种基本状态

- 就绪、执行、阻塞

同样存在进程的调度

对进程的操作影响到进程中的所有线程

**线程的基本操作**

- 派生（Spawn)：当产生一个新进程时，同时也为该进程派生了一个线程，随后，进程中的线程可以在同一个进程中派生另一个线程，新线程被放置在就绪队列中。

- 阻塞（Block)：当线程需要等待一个事件时，它将阻塞，此时处理器转而执行另一个就绪线程。

- 解除阻塞（Unblock）：当阻塞一个线程的事件发生时，该线程被转移到就绪队列中。

- 结束（Finish）：当一个线程完成时，其寄存器的信息和栈都被释放。

- 线程的实现
  - 用户级线程
    - 线程的管理由应用程序完成
  - 内核级线程
    - 线程的管理由内核完成，应用程序通过API访问线程

![用户级线程和内核级线程](img\用户级线程和内核级线程.png)

a. 用户级线程，操作系统感知不到线程存在，只知道进程存在。信息交换只在用户空间完成

b. 内核级线程，调用API完成，操作系统可以感知到。用户控件不能完成信息交换，需要调用API在内核完成信息交换，需要模式切换有较大开销。

**用户级线程**与内核级线程的比较

- 用户级线程不需要模式切换（由应用程序完成）

- 用户级线程由应用程序实现调度管理

- 用户级线程可以在任意操作系统中运行（语言提供用户级线程库）

**缺点**

- 用户级线程执行系统调用时，同一进程所有线程都会被阻塞

- 不能利用多处理机技术

用户级线程与**内核级线程**的比较

- 内核实现内核级线程的调度管理

- 可以充分利用多处理机技术

**缺点**

- 有模式切换的开销

## 进程的并发

并发是所有问题的基础，也是操作系统设计的基础

由并发带来的两个问题

- 对资源的相互制约：同步

- 对资源的相互共享：互斥

### 相关的关键概念

- 临界资源：一次仅允许一个进程访问的资源为临界资源

- 临界区
  - 把在每个进程中访问临界资源的那段**代码**称为临界区
  - 代码作为一个共享资源，一次只能允许一个进程访问

- 死锁：两个或两个以上的进程相互等待导致都不能执行

- 活锁：由于某些条件不满足，导致进程不断重复尝试而不能正常推进执行

- 互斥：当一个进程在临界区访问临界资源时，其他进程不能进入该临界区访问共享资源

- 竞争：多个进程读写一个共享数据时依赖它们执行的相对时间
  - 竞争条件发生在多个进程或线程读写数据时，其最终结果取决于多个进程的指令执行顺序

- 饥饿：一个进程得不到执行机会（P134）

合作关系：直接知道（直接通信），间接知道（通过共享）

进程的并发会导致程序执行结果不封闭

- 全局资源

  对全局资源的访问秩序非常重要

- 资源分配

  不好的分配算法可能导致死锁

为了实现对临界资源的访问，每个进程都**互斥**地进入自己的临界区：**一次只有一个程序在临界区**

1. 进入临界区之前，对预先访问的临界资源进行检查

2. 若该资源尚未被访问，则可以进入临界区；反之则不能

3. 设置正在访问标志

最后，将资源恢复为未访问标志

### 互斥可能带来的问题

- 死锁：进程P1占有资源R1，等待资源R2；进程P2占有资源R2，等待资源R1

- 饥饿：无限期地被推迟访问

#### 同步机制应该遵循的准则

1. **空闲让进**（临界区没有进程就让进）
2. **忙则等待**（只有一个进程进入临界区）
3. **有限等待**
4. **让权等待**

#### 实现互斥访问

- 严格轮换

	每个进程每次都从头执行到尾

- 屏蔽中断

	刚刚进入临界区时就屏蔽中断，刚要出临界区就打开中断

- 专用机器指令

	test_and_set、test_and_clear 

- 软件方法

	信号量

### 软件方法解决互斥与同步

1. 能否保住互斥？
2. 会不会出现互斥礼让？
3. 会不会死锁？

算法分析（ Dekker’s Algorithm ）

```c
Int turn=0; //共享的全局变量
Process 0
{
    while turn≠0 do {nothing};
    <critical section>;
    turn=1;
}
Process 1
{
    while turn ≠ 1 do {nothing};
    <critical section>;
    turn=0;
}
```

解析：保证了互斥，但存在问题：进程“忙等”进入临界区；若黑板标志修改失败，其他进程**永久阻塞**

-------

```c
boolean flag[2]; //共享的全局变量
Process 0
{
    while flag[1] do {nothing};
    flag[0]=true;
    <critical section>;
    flag[0]=false;
}
Process 1
{
    while flag[0] do {nothing};
    flag[1]=true;
    <critical section>;
    flag[1]=false;
}
```

若进程执行完临界区，恢复自己标志为“false”失败，则其他进程永久阻塞。

-------

在检查其他进程之前，希望进到临界区，则设置自己 flag=true。

当设置标志为真后，如果其他进程在临界区，则本进程阻塞，直到其他进程释放临界区为止。

```c
var flag : array [0，1] of boolean :false ;
Process 0
{
    flag[0]=true;
    while flag[1] do {nothing};
    <critical section>;
    flag[0]=false;
}
Process 1
{
    flag[1]=true;
    while flag[0] do {nothing};
    <critical section>;
    flag[1]=false;
}
```

如果两个进程在执行while之前都把flag设置成true，那么每个进程都会以为对方进入了临界区，使自己处于阻塞，从而导致死锁。

-------

主要思想是将标志重置，不会发生死锁。

实现过程：

- 希望进到临界区，则设置自己 标志为：flag=true。
- 如果其他进程在临界区，则将本进程标志置为flag=false，稍后又置为true，这一过程重复到能进入临界区为止。

```c
var flag : array [0，1] of boolean :false ;
Process 0
{
    flag[0]=true;	//希望进入临界区
    while flag[1] do {
        flag[0]=false;
        <delay for a shot time>;
        flag[0]=true;
    };
    <critical section>;
    flag[0]=false;
}
Process 1
{
    flag[1]=true;
    while flag[0] do {
    	flag[1]=false;
        <delay for a shot time>;
        flag[1]=true;
    };
    <critical section>;
    flag[1]=false;
}
```

检查其它进程，然后重置，再检查，再重置…，

重置序列可以无线延伸，任何一个进程都不能进入自己的临界区。(这种现象称为:互斥礼让)

互斥礼让的第二种方法

```c
var flag : array [0，1] of boolean :false ;
turn : 0,1;
Process 0
{
    flag[0]=true;	//希望进入临界区
    turn = 1;
    while flag[1] && turn == 1 do { nothing };
    <critical section>;
    flag[0]=false;
}
Process 1
{
    flag[1]=true;
    turn = 0;
    while flag[0] && turn == 0 do { nothing };
    <critical section>;
    flag[1]=false;
}
```



## 进程的并发

常用并发机制

1. 信号量

   以上三个整数值（初始化，+，-）都是原子操作，如果操作失败会撤销

2. 二元信号量

   只取0,1

3. 互斥量

   加锁和解锁的量必须是同一个

4. 条件变量
5. 管程
6. 事件标志
7. 信箱/消息
8. 自旋锁

### 信号量

#### 整形信号量

最初由Dijkstra把整型信号量定义为一个整型量，除初始化外，仅能通过两个标准的**原子操作**(Atomic Operation) wait(S)和signal(S)来访问。这两个操作一直被分别称为P、V操作。 wait和signal操作可描述为：
```c
P(S):  while (S<=0); S=S-1;
V(S):  S=S+1;
```

p(wait) v(signal)

不能对信号量直接做加减操作，因为操作不满足原子操作。需要调用P和V函数

面临的问题

- 只要是信号量S≤0， 就会不断地测试。因此，该机制并未遵循“让权等待”的准则

可能存在盲等

#### 记录型信号量

一个用于代表资源数目的整型变量value外

一个进程链表L，用于链接所有等待进程

````c
typedef struct semaphore{
	int Value;
    List_of_Process L;
}

P(S):
     S.value  =S.value-1;
     if  (S.value<0)
          block(S,L);//切换至阻塞队列
         
V(S):
     S.value=S.value+1;
     if  (S.value<=0)
         wakeup(S,L); 
````

S.value的初值表示系统中某类资源的数目，因而又称为资源信号量，对它的每次wait操作，意味着进程请求一个单位的该类资源，因此描述为S.value=S.value-1；

当S.value＜0时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到信号量链表S.L中。可见，该机制遵循了“让权等待”准则。 此时S.value的绝对值表示在该信号量链表中已阻塞进程的数目。

对信号量的每次signal操作，表示执行进程释放一个单位资源，故S.value=S.value+1操作表示资源数目加1。若加1后仍是S.value≤0，则表示在该信号量链表中，仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S.L链表中的第一个等待进程唤醒。

如果S.value的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为互斥信号量。

强信号量，按排队顺序唤醒。弱信号量，唤醒资源靠竞争

![Semaphore_Mechanism](img\Semaphore_Mechanism.png)

#### AND信号量

AND同步机制的基本思想

**将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。**亦即，对若干个临界资源的分配，采取原子操作方式：要么全部分配到进程，要么一个也不分配。

#### 信号量集

思考：记录型信号量有何不便之处？

- 当一次需要多个资源时，需要进行多次P操作

- 同理，要进行多次释放V操作

如何改进：

t为下限值，d为需求值

```c
Swait(S1, t1, d1, …, Sn, tn, dn)
    if ( S1≥t1 and … and Sn≥tn )
       for  ( i=1;i<=n; i++)
             Si =Si-di;
    else
        Place the executing process in the waiting queue of the first Si with Si＜ti and set its program counter to the beginning of the Swait Operation. ;
signal(S1, d1, …, Sn, dn)
   for  ( i=1;i<=n; i++){
       Si =Si+di;
       Remove all the process waiting in the queue associated with Si into the ready queue;
   } 
```

一般“信号量集”的几种特殊情况：

1. Swait(S, d, d)。 此时在信号量集中只有一个信号量S， 但允许它每次申请d个资源，当现有资源数少于d时，不予分配。
2. Swait(S, 1, 1)。 此时的信号量集已蜕化为一般的记录型信号量(S＞1时)或互斥信号量(S=1时)。
3. Swait(S, 1, 0)。这是一种很特殊且很有用的信号量操作。当S≥1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。

### 信号量的应用

**利用信号量实现进程互斥**

```c
P1:
Semaphore mutex=1;
while(1){
    P(mutex);
    Critical Section;
    V(mutex);
}
P2:
Semaphore mutex=1;
while(1){
    P(mutex);
    Critical Section;
    V(mutex);
}
```

**利用信号量实现前趋关系**

```mermaid
graph LR
a(S1)--a-->b(S2)
a--b-->c(S3)
b--c-->d(S4)
b--d-->e(S5)
d--f-->f(S6)
e--g-->f(S6)
c--e-->f(S6)
```

需要保证在前趋结束，才能开始执行后面的进程

```c
Semaphore a=0,b=0,c=0,d=0,e=0,f=0,g=0;//使用信号量必须初始化
S1;V(a);V(b);
P(a);S2;V(c);V(d);
P(b);S3;V(e);
P(c);S4;V(f);
P(d);S5;V(g);
P(e);P(f);P(g);S6;
```

同一层级的执行顺序靠调度

**生产者消费者问题**

1. 生产者生产产品，提供给消费者去消费。

2. 为使得生产者进程和消费者进程能并发执行（执行中可能会被打断），在两者之间设置了具有*n*个缓冲区的缓冲池。

3. 生产者进程将他生产的产品放入缓冲池（一次一个），消费者进程从缓冲池中拿走产品（一次一个）。

4. 缓冲池已满时，生产者不能再放，缓冲池已空时，消费者不能再拿。

生产者与消费者之间的联系

- 互斥
  - 共享缓冲区（缓冲区作为一种临界资源）

- 同步
  - 相互等待（有产品才能消费、有消费才能不断生产）

使用循环缓存，只需要单一方向生成/消费即可

假定在生产者和消费者之间的公用缓冲池中，具有n个缓冲区，这时可利用**互斥信号量Mutex**实现诸进程对缓冲池的互斥使用

利用**信号量Empty和Full**分别表示缓冲池中空缓冲区和满缓冲区的数量。

```c
Semaphore Mutex=1; //定义互斥信号量，注意是1
Semaphore Full=0;Empty=n; //定义同步信号量
//这样初始化是为了阻塞消费者，此时消费者可用资源为0，n是缓冲区大小为生产者可生产空位
product_Item Buffer[n]; //定义产品缓冲区
int in=0; //定义生产者初始化指针
int out=0; //定义消费者初始化指针

Producer://	生产者进程
while(1){
    ...; // 生产者生产产品 Pro_Item
    P(Empty);
    P(Mutex);//加锁
    Buffer[in]=Pro_Item;
    in=(in++)%n;
    V(Mutex);//解锁
    V(Full);
}

Consumer:
while(1){
    P(Full);
    P(Mutex);
    Item=Buffer[out];
    out=(out++)%n;
    V(Mutex);
    V(Empty);
    ...; //消费者消费过程
}
```

互斥信号量：PV同一进程中成对

同步信号量：PV不同进程中成对

如果 empty和Mutex 交换 会导致死锁，产生原因 生产者连续生产n次后，再次进行P([pro]mutex) P1([pro]empty) P2([con]mutex) 死锁

因此

1. P操作一定要对同步信号量操作，再对互斥信号量操作
2. PV成对出现

P不当会导致死锁，V操作不会导致阻塞

#### 利用AND信号量

```c
Semaphore Mutex=1; //定义互斥信号量，注意是1
Semaphore Full=0;Empty=n; //定义同步信号量
//这样初始化是为了阻塞消费者，此时消费者可用资源为0，n是缓冲区大小为生产者可生产空位
product_Item Buffer[n]; //定义产品缓冲区
int in=0; //定义生产者初始化指针
int out=0; //定义消费者初始化指针

Producer://	生产者进程
while(1){
    ...; // 生产者生产产品 Pro_Item
    P(Empty,Mutex);
    Buffer[in]=Pro_Item;
    in=(in++)%n;
    V(Mutex,Full);//解锁
}

Consumer:
while(1){
    P(Full,Mutex);
    Item=Buffer[out];
    out=(out++)%n;
    V(Mutex，Empty);
    ...; //消费者消费过程
}
```

#### 无限缓存

缓冲区无限大

生产者不停地放

满足：

1. 互斥
2. 消费者有限制

```c
int n;
binary_semaphore s = 1,delay = 0;//二元信号量
void producer(){
    while(true){
        produce();
        semWaitB(s);
        append();
        n++;
        if(n == 1)semSignalB(delay);//通知消费者有数据可取
        semSignalB(s);
    }
}
void consumer(){
    semWaitB(delay);
    while(true){
        semWaitB(s);
        take();
        n--;
        semSignalB(s);
        consume();
        if(n == 0) semWaitB(delay);
    }
}
void main(){
    n = 0;
    parbegin(producer, consumer);
}
```

以上程序存在错误

|      | Producer                   | Consumer                                            | s    | n    | Delay |
| ---- | -------------------------- | --------------------------------------------------- | ---- | ---- | ----- |
| 1    |                            |                                                     | 1    | 0    | 0     |
| 2    | semWaitB(s)                |                                                     | 0    | 0    | 0     |
| 3    | n++ //生产                 |                                                     | 0    | 1    | 0     |
| 4    | if(n==1) semSignalB(delay) |                                                     | 0    | 1    | 1     |
| 5    | semSignalB(s)              |                                                     | 1    | 1    | 1     |
| 6    |                            | semWaitB(delay)                                     | 1    | 1    | 0     |
| 7    |                            | semWaitB(s)                                         | 0    | 1    | 0     |
| 8    |                            | n-- //消费                                          | 0    | 0    | 0     |
| 9    |                            | semSignalB(s)                                       | 1    | 0    | 0     |
| 10   | semWaitB(s)                |                                                     | 0    | 0    | 0     |
| 11   | n++// 生产                 |                                                     | 0    | 1    | 0     |
| 12   | if(n==1) semSignalB(delay) |                                                     | 0    | 1    | 1     |
| 13   | semSignalB(s)              |                                                     | 1    | 1    | 1     |
| 14   |                            | if(n==0) :warning:semWaitB(delay) //这里delay不匹配 | 1    | 1    | 1     |
| 15   |                            | semWaitB(s)                                         | 0    | 1    | 1     |
| 16   |                            | n-- //这里消费空数据                                | 0    | 0    | 1     |
| 17   |                            | semSignalB(s)                                       | 1    | 0    | 1     |
| 18   |                            | if(n==0) :warning:semWaitB(delay)                   | 1    | 0    | 0     |
| 19   |                            | semWaitB(s)                                         | 0    | 0    | 0     |
| 20   |                            | n--:stop_sign:                                      | 0    | -1   |       |

主要问题是生产者和消费者对于n同时进行操作，消费者消费了一个不存在的内容

正确的程序

```c
int n;
binary_semaphore s = 1,delay = 0;//二元信号量
void producer(){
    while(true){
        produce();
        semWaitB(s);
        append();
        n++;
        if(n == 1)semSignalB(delay);//通知消费者有数据可取
        semSignalB(s);
    }
}
void consumer(){
    int m; // a local variable
    semWaitB(delay);
    while(true){
        semWaitB(s);
        take();
        n--;
        m = n;
        semSignalB(s);
        consume();
        if(m == 0) semWaitB(delay);
    }
}
void main(){
    n = 0;
    parbegin(producer, consumer);
}
```

这里的n类似一个信号量，所以不使用二元函数，进行改进

```c
semaphore n = 0, s = 1;
void producer(){
    while(true){
        produce();
        semWait(s);
        append();
        semSignal(s);
        semSignal(n);
    }
}
void consumer(){
    while(true){
        semWait(n);
        semWait(s);
        take();
        semSignal(s);
        consume();
    }
}
void main(){
    parbegin(producer, consumer);
}
```

#### 哲学家就餐问题

```c
Semaphore Chopstick[n]={1,1,1,1,1} //定义n个共享资源
while(1){
    P(Chopstick[i]); //第i个人拿起他左边的筷子
    P(Chopstick[(i+1)%n]); //拿起他右边的筷子
    Eating...;
    V(Chopstick[(i+1)%n]);
    V(Chopstick[i]);
    Thinking or Computing..;
}
```

每根筷子相当于一个互斥信号量，拿左边筷子后容易拿不到右边筷子导致死锁

解决方法：and信号量，最多n-1个人同时拿筷子（鸽笼原理，抽屉原理）

#### 盘子问题

有一个空盘，只能放一个水果，父亲往盘子里放一个苹果或一个橘子，儿子只拿橘子，女儿只拿苹果

需要参考生产者消费者模型，

互斥信号量：盘子（临界资源）

同步信号量：资源信号量（针对消费者，针对生产者）

```c
Semaphore Mutex = 1;
Semaphore Empty = 1;
semaphore s_apple = 0,s_oranger = 0;
father:
while(1){
    P(empty);
    P(mutex);
    Put fruit;
    if(Orange) V(s_oranger);
    else V(s_apple);
    V(mutex);
}
son:
while(1){
    P(s_Orange);
    P(mutex);
    Fetch Orange;
    V(Empty)
    V(mutex);
    Eating;
}
daughter:
while(1){
    P(s_apple);
    P(mutex);
    Fetch Apple;
    V(Empty)
    V(mutex);
    Eating;
}
```

通过以上例子可以说明：

1. 一定先P(资源信号量)，再P(互斥信号量)
2. 一定不能忘记对生产者也有资源信号量

#### 读写问题

多个进程对同一个文件进行读写，要求

- 不能同时写文件
- 不能同时读和写文件
- 可以同时读文件

为实现Reader与Writer进程间在读或写时的互斥而设置了一个**互斥信号量Wmutex**。

设置一个**整型变量Readcount表示正在读的进程数目**。由于只要有一个Reader进程在读，便不允许Writer进程去写。因此，仅当Readcount=0, 表示尚无Reader进程在读时，Reader进程才需要执行Wait(Wmutex)操作。若wait(Wmutex)操作成功，Reader进程便可去读，相应地，做Readcount+1操作。同理，仅当Reader进程在执行了Readcount减1操作后其值为0时，才须执行signal(Wmutex)操作，以便让Writer进程写。

Readcount是一个可被多个Reader进程访问的临界资源，因此，应该为它设置一个互**斥信号量rmutex**。 

```c
Semaphore Rmutex=1,Wmutex=1;
int ReaderCount=0;
Reader:
while(condition){
    P(Rmutex); //对共享资源Rmutex加锁
    if(ReaderCount==0){
        P(Wmutex); //读之前对临界资源文件加锁
    }
    ReaderCount++;
    V(Rmutex);
    //开始读
    P(Rmutex);
    ReaderCount--;
    if(ReaderCount==0){
        V(Wmutex); //若无读进程，对临界资源进行写解锁
    }
    V(Rmutex); //对Rmutex解锁
}
Writer:
while(condition){
    P(Wmutex);
    //写文件
    V(Wmutex);
}
```

```mermaid
stateDiagram
state 请求顺序{
R0 --> W0
W0 --> R1
R1 --> R2
}
请求顺序 --> 实际顺序:运行乱序
state 实际顺序{
R0 --> R1
R1 --> R2
R2 --> W0
}
```

这样就导致了，只要就读者就无法修改内容。所以需要进行优化，让写者优先

```c
int readcount,writecount;//调用时，初始化为0
semaphore x = 1, y = 1, z = 1, wsem = 1, rsem = 1;
/* rsem:至少有一个进程准备访问数据区时，用于禁止所有的读进程
writecount:控制rsem
y:控制writecount更新
*/
void reader(){
    while(true){
        semWait(z);
        semWait(rsem);
        semWait(x);
        readcount++;
        if(readcount==1) semWait(wsem);
        semSignal(x);
        semSignal(rsem);
        semSignal(z);
        READUNIT();
        semWait(x);
        	readcount--;
        	if(readcount == 0) semSignal(wsem);
        semSignal(x);
    }
}
void writer(){
    while(true){
        semWait(y);
        	writecount++;
        	if(readcount == 1) semWait(rsem);            
        semSignal(y);
        semWait(wsem);
        READUNIT();
        semSignal(wsem);
        semWait(y);
        	writecount--;
        	if(readcount == 0) semSignal(rsem);
        semSignal(y);
    }
}
```

将三个经典例子牢记于心

- 生产者消费者问题：需要相互通知
- 哲学家就餐问题：需要
- 读写问题：间接知道（甚至不知道），团体问题

参考其他示例

- 理发师问题

解决P、V操作问题的关键

- 理解临界资源与临界区的概念！
- 准确理解问题的同步互斥过程与要求！
  - 同步：多个进程在执行次序上的协调，相互等待消息
  - 互斥：对临界资源的使用
- 建立信号量，准确定义信号量的意义和初始值！
- 信号量的定义根据同步和互斥要求来定

## 管程 Monitor

定义：管理进程同步与互斥的一种工具

Hansan为管程所下的定义是：“一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据”

![Monitor](img\Monitor.png)

```c
char x;
void producer(){
    produce(x);
    append(x);//管程中的操作（方法）
}
void consumer(){
    take(x);
    consume(x);//管程中的操作（方法）
}
char buffer[n];
int nextin,nextout;
int count; //产品的数目
int notfull,notempty;
void append(char x){
   	if(count == n) cwait(notfull);
    buffer[nextin] = x;
    nextin = (nextin + 1)%n;
    count++;
    csignal(notempty);
}
void take(char x){
   	if(count == n) cwait(notempty);
    x = buffer[nextout];
    nextin = (nextin + 1)%n;
    count--;
    csignal(notfull);
}
```

消费者和生产者都需要调用管程中的工具，只有管程可以访问缓冲区，所以不需要进行互斥访问，一次只有一个进程通过管程访问缓冲区。

**管程的主要特点：**

- 局部数据变量只能被管程的过程访问，任何外部过程都不能访问。
- 一个进程通过调用管程的一个过程进入管程。
- 在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被挂起，以等待管程变成可用的。
- 为进行并发处理，管程必须包含同步工具
- 管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有在管程中才能被访问。有两个函数可以操作条件变量：
  - Cwait(c)：调用进程的执行在条件c上挂起，管程现在可被另一个进程使用
  - Csignal(c)：恢复在cwait之后为某些条件而挂起的进程的执行。如果有多个这样的进程，选择其中一个；如果没有这样的进程，什么也不做

## 进程间通信 IPC

PV操作用于进程的同步与互斥，是低级进程通信

不使用PV操作的：网络进程通信，数据交换量较大的单机进程通信

解决方法

### 消息传递

直接消息传递

- 两个或多个进程利用系统调用相互发送消息

  Send(Destination, &message) 原语

  Receive(Source, &message)

  安全问题

  - 消息丢失、对象假冒、消息篡改……

- 阻塞Send，阻塞Receive

  无阻塞Send，阻塞Receive

  无阻塞Send，无阻塞Receive

间接消息传递

- 不直接发给消息的接收者，而是发到某个共享空间。

  消息的接收者和发送者之间的关系是不定的

  - 一对一

  - 多对多

  - 一对多

  - 多对一

  共享空间的所有权问题

### 共享存储器系统

- 基于共享数据结构的通信方式
  - 公用某一个数据结构实现信息交换
  - 缺点：难，低效，数据量较少

基于共享存储区的通信方式（邮箱）

- 划分一块存储空间作为公用

### 管道通信

连接两个进程：读进程，写进程

- 写进程以字符流形式输入管道
- 读进程以字符流形式接收输入

注意事项

- 互斥
- 同步
- **互相确定对方存在**则开始通信

Unix系统中管道的限制

- 以半双工方式工作
- 使用管道的进程具有**共同的祖先**

由Pipe函数创建管道

```c
#include <unistd.h>
int pipe(int fd[2]);
```

fd[2]为两个文件描述符，0为读，1是写，fd[1]的输出是fd[0]的输入

如果成功返回0，否则返回-1

## 进程调度

### 进程调度的基本概念

- 分配处理机的任务是由进程调度程序完成的
- 由于处理机是最重要的计算机资源，提高处理机的利用率及改善系统性能（吞吐量、响应时间），在很大程度上取决于进程调度性能的好坏

长程调度

- 用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就绪队列上，准备执行 
- 通常也被称为作业调度

中程调度 

- 称为中级调度
- 引入中程调度的主要目的，是为了提高内存利用率和系统吞吐量。 

短程调度 

- 称为进程调度
- 用来决定就绪队列中的哪个进程应获得处理机，然 后再由分派程序把处理机分配给该进程的具体操作

调度的目标：

1. 提高处理机的利用率

2. 提高系统吞吐量

3. 尽量减少进程的响应时间

4. 防止进程长期得不到运行

调度的原则：满足用户的需要和系统的需要

### 面向用户的准则

- 周转时间

  - 从作业被提交给系统开始，到作业完成为止的这段时间间隔（称为作业周转时间）

  - 作业在外存后备队列上等待调度的时间

    进程在就绪队列上等待进程调度的时间

    进程在CPU上执行的时间

    进程等待I／O操作完成的时间

- 响应时间

  - 从用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间

  - 响应时间包括三部分时间：

    1. 从键盘输入的请求信息传送到处理机的时间

    2. 处理机对请求信息进行处理的时间

    3. 将所形成的响应信息回送到终端显示器的时间

- 截止时间：某任务必须开始执行的最迟时间，或必须完成的最迟时间

- 公平性：各进程在系统中都能平等的得到运行

- 优先权：让某些紧急的作业能得到及时处理

### 面向系统的准则

- 系统吞吐量高[^1]
- 处理机利用率好
- 各类资源的平衡利用

进程调度可采用下述两种调度方式

- 非剥夺（抢占）方式（Non-preemptive）

   在采用这种调度方式时，一旦把处理机分配给某进程后，便让该进程一直执行，直至该**进程完成**或发生某事件而被**阻塞**时，才再把处理机分配给其他进程，决不允许某进程抢占已经分配出去的处理机

- 剥夺（抢占）方式（Preemptive）

   允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程

剥夺的原则：

- 优先权原则 
- 短作业（进程）优先原则
- 时间片原则

### 调度算法 分时系统

FCFS (First-Come-First-Served) 先来先服务

通常也被称为FIFO

RR （Round-Robin）时间片轮转 抢占式

SPN (Shortest Process Next, STN) 短进程优先 非抢占式

SRT (Shortest Remaining Time) 最短剩余时间优先(抢占式短作业优先)

HRRN (Highest Response Ratio Next) [^2]高响应比优先 非抢占式

Feedback 反馈 抢占式

|             | A    | B    | C    | D    | E    |      |
| ----------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 到达时间    | 0    | 2    | 4    | 6    | 8    |      |
| 服务时间    | 3    | 6    | 4    | 5    | 2    |      |
| FCFS        |      |      |      |      |      | 平均 |
| 完成时间    | 3    | 9    | 13   | 18   | 20   |      |
| 周转时间T_r | 3    | 7    | 9    | 12   | 12   | 8.6  |
| T_r/T_s     | 1.00 | 1.17 | 2.25 | 2.40 | 6    | 2.56 |

![时间片轮转](进程与线程.assets/时间片轮转.png)

![抢占与非抢占](进程与线程.assets/抢占与非抢占.png)

抢占：当前最小剩余执行时间的进程就可以抢占

![高响应比优先](进程与线程.assets/高响应比优先.png)

高响应比优先，非抢占式算法分配后直到运行完都不会有其他进程
$$
高响应比=\frac{等待时间+要求服务时间}{要求服务时间}=1+\frac{W}{S}
$$

feedback q=1 每个进程分配一个时间片，每次运行下降一级，从最上层往下调度

A RQ0,RQ1到RQ2 

B到达RQ0，就行到RQ1 此时队组里面只有A，调度A A结束

C达到RQ0，下到RQ1 队中只有B，调度B

D达到RQ0....

feedback q=2^i 各级队列的时间片按指数式增长

#### Feedback多级反馈式调度算法

![Feedback](进程与线程.assets/Feedback.png)算法思想：对其他调度算法的折中权衡

算法规则

1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾
3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片

用于进程调度

抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。

优缺点

对各类型进程相对公平(FCFS的优点) ;每个新到达的进程都可以很快就得到响应(RR的优点) ;短进程只用较少的时间就可完成(SPF的优点) :不必实现估计进程的运行时间(避免用户作假) ;可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展:可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级)
会导致饥饿  

### 实时系统调度

非抢占式优先权算法

- 一旦将处理机分配给某个进程，则让它一直运行直到结束。下次启动调度程序时选择优先权最高的进程

抢占式优先权调度算法

- 可以很快地抢占CPU资源

![常见调度](进程与线程.assets/常见调度.png)

a. 实时性差，实时系统一般不采用

d. 不等待时钟到达，立即抢占，实时性好

实时调度（P290-295 8版 自学）

- 静态表法
- 静态优先级抢占法
- 动态规划法
- 动态尽力调度

优先级反转：系统内环境迫使优先级高的进程需要等待优先级低的进程

如p1访问临界资源，p2后p3访问临界资源的时候必须等待p1

如何避免优先级反转

- 优先级继承
- 优先级天花板

## 死锁

产生死锁的原因

竞争资源

- 可剥夺和非剥夺性资源 
- 竞争非剥夺性资源 
- 竞争临时性资源 

进程间推进顺序不当

![进程间执行顺序不当](进程与线程.assets/进程间执行顺序不当.png)

P和Q两个进程推进，当3和4线路时（P有资源A，Q有资源B）继续执行就会产生死锁。如果拿到临界就释放资源，不会导致死锁

前提P-->结论Q P是Q的充分条件，Q是P的必要条件

### 产生死锁的必要条件

1. 互斥条件
2. 请求和保持条件
3. 不剥夺条件
4. 环路等待条件

1,2,3是必要非充分条件（死锁可以推出1,2,3条件），4是

### 处理死锁的基本方法

1. 预防死锁
   - 摒弃“请求和保持”条件 
   - 摒弃“不剥夺”条件
   - 摒弃“环路等待”条件
2. 避免死锁
3. 检测死锁
4. 解除死锁

and信号量破坏了请求和保持条件，定义选项线性顺序是破坏了环路等待条件

**死锁预防，约束资源强求，防止任意条件发生**

**死锁避免，不破坏必要条件，允许存在，通过策略让系统不会到达死锁点**

#### 资源分配拒绝 银行家算法

一种死锁避免算法，定义状态和安全状态

##### 安全状态

在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，令进程等待。

所谓安全状态，是指系统能按某种进程顺序(P1, P2, …，Pn)(称〈P1, P2, …, Pn〉序列为安全序列)，来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。

按照资源的某种顺序，使得所有进程都能执行完毕，那么就是安全的

资源总量 - 所有分配出的资源 = 可以资源 （类似投资的概念，用可用资源换取更多可用资源）

#### 利用银行家算法避免死锁

假定系统中有五个进程｛P0, P1, P2, P3, P4｝和三类资源｛A, B, C｝，各种资源的数量分别为10、5、7，在*T*0时刻的资源分配情况如图 3-15 所示。 

| 进程\资源情况(A B C) | Max   | Alloction | Need  | Available                     |
| -------------------- | ----- | --------- | ----- | ----------------------------- |
| P0                   | 7 5 3 | 0 1 0     | 7 4 3 | 3 3 2                         |
|                      |       |           |       | 2 3 0                         |
| P1                   | 3 2 2 | 2 0 0     | 1 2 2 | 5 3 2(分配后获得分配和已分配) |
|                      |       | 3 0 2     | 0 2 0 | 7 4 3(如果投给P0)             |
| P2                   | 9 0 2 | 3 0 2     | 6 0 0 | 7 5 3                         |
| P3                   | 2 2 2 | 2 1 1     | 0 1 1 | 10 5 5                        |
| P4                   | 4 3 3 | 0 0 2     | 4 3 1 | 10 5 7                        |

全部序列安全

P1请求资源：P1发出请求向量Request1(1，0，2) <--(尝试满足，并检查安全状态，如果不满足安全必定死锁就不用分配)，系统按银行家算法进行检查：

1. Request1(1, 0, 2)≤Need1(1, 2, 2)
2. Request1(1, 0, 2)≤Available1(3, 3, 2)
3. 系统先假定可为P1分配资源，并修改Available, Allocation1和Need1向量，由此形成的资源变化情况如图 3-15 中的圆括号所示
4. 再利用安全性算法检查此时系统是否安全

#### 死锁检测与解除

##### 资源分配图resource allocation graph

```mermaid
graph LR
P1 --> r2[r2 两个资源]
r2 --> P2
P2 --> r1[r1 三个资源]
r1 --> P1
P1 --> r1
r1 --> P2
```

每类资源有多个时的情况

##### 死锁检测算法

![死锁检测算法](进程与线程.assets/死锁检测算法.png)

请求矩阵Q 资源分配矩阵A，初始化都没有标记死锁

1. 标记分配矩阵中全为0的行，没有已分配的资源，P4
2. 初始化临时向量W等于可用向量，W = (0 0 0 0 1)
3. 寻找下标i，使得未标记Q的第i行小于等于W。若对所以的1<=k<=m，Qik<=Wk找不到这样的行，终止算法。进程P3请求小于等于W，请求比当前空余小，标记P3，令W=W+(0 0 0 1 0)=(0 0 0 1 1)
4. 其他未标记的进程Q的行小于等于W

## 总结

进程执行控制模型：顺序，并行，并发

进程控制：PCB，状态-->状态转换图

进程同步互斥:star: 严格轮换，屏蔽中断，机器指令，软件，信号量，管程

- 信号量：整形信号量，记录型，AND，信号量集
- 利用信号实现同步与互斥
  - 生产者-消费者
    - 同步信号量/资源信号量=可用资源数目
    - 互斥信号量=1
  - 读写问题：读优先
  - 哲学家就餐问题：死锁

进程的通信：

- 高级通信（大量数据交换）
  - 共享存储器
    - 共享存储区
    - 共享数据结构
  - 消息传递
    - 直接消息传递
    - 间接消息传递
  - pipe
- 低级通信（同步，互斥）

进程的调度

1. FCFS
2. 优先级
3. SPN短作业优先（非抢）
4. SRN最短剩余时间优先，抢占式短进程(平均周转时间)[^3]
5. 时间片轮转
6. 高响应比优先HRRF（非抢）
7. 多级反馈队列

进程的死锁：必要条件，充要条件

- 预防：摒弃“请求和保持”条件，摒弃“不剥夺”条件 ，摒弃“环路等待”条件 
- 避免
  - 银行家，死锁避免算法

推荐阅读：linux 0.11内核

-------

进程如果阻塞了，还会占用已经申请的资源。如果进程占用所有资源，其他进程得不到资源需要一直等到释放。如果造成严重问题需要进行剥夺或人工干预

[^1]:指在单位时间内，系统所完成的作业数
[^2]:R = 1 + w/s Wait和Save

[^3]:证明过程

假设有n个作业，按照运行时间排序t1 < t2 <... < tn
平均周转时间 = （总的运行时间 + 总的等待时间）/n
其中总的运行时间是定值，n为定值，因此要平均周转时间最短既要求总的等待时间最短。

按照最短作业优先，设第i个作业的等待时间为ai.则
a1 = 0
a2 = t1
a3 = t1 + t2
....
an = t1 + t2 + ... + t(i-1)
总的等待时间为a1 + a2 + a3 + ... + an

现在只需要证明这个是最小就可以了。任意取2个作业i 和 j。 且ti < tj。交换ti和tj的顺序。
则新等待时间变成b0 b1 b2 .... b(i-1)  bi b(i+1) ..... b(j-1) bj b(j+1) ... bn 其中b0 + b1 + ... + b(i-1) + bi与原来的a相等。 
b(i+1) = t1 + t2 + ... + t(i-1) + tj > t1 + t2 + ... + t(i-1) + ti = a(i+1)
依次类推之后bx > ax  其中i < x < j+1.之后b与a又相等。
所以任意交换后，等待时间变大。所以最小作业优先的等待时间最小。所以平均周转时间最短。

