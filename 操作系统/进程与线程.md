# 进程和线程 Processes and Threads

## 自己动手引导计算机启动

所需软件

- Virtual Box, VMware等虚拟机软件
- Ubuntu，RedHat等Linux发行版
- Windows
- Linux下的汇编编译器nasm
- 程序源文件编辑器
- Internet

```assembly
	org	07c00h			; 告诉编译器程序加载到7c00处
	mov	ax, cs
	mov	ds, ax
	mov	es, ax
	call	DispStr			; 调用显示字符串例程
	jmp	$			; 无限循环
DispStr:
	mov	ax, BootMessage
	mov	bp, ax			; ES:BP = 串地址
	mov	cx, 16			; CX = 串长度
	mov	ax, 01301h		; AH = 13,  AL = 01h
	mov	bx, 000ch		; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮)
	mov	dl, 0
	int	10h			; 10h 号中断
	ret
BootMessage:		
	db	"Hello, OS world!"
	times 	510-($-$$)	db	0; 填充剩下的空间，使生成的二进制代码恰好为512字节
	dw 	0xaa55				; 结束标志

```

1. 编写汇编程序

2. https://blog.csdn.net/judyge/article/details/52278384

3. 用nasm编译上述汇编程序

   nasm boot.asm - o boot.bin

   提示:需要先安装nasm工具，在Ubuntu环境下，使用： sudo apt-get install nasm即可

4. 将bin文件转换成可启动的映像文件

   ```bash
   $dd if=boot.bin of=boot.img bs=512 count=1
   1+0 records in
   1+0 records out
   512 bytes copied, 0.000222849 s, 2.3 MB/s
   $dd if=/dev/zero of=boot.img skip=1 seek=1 bs=512 count=2879
   2879+0 records in
   2879+0 records out
   1474048 bytes (1.5 MB, 1.4 MiB) copied, 0.0214993 s, 68.6 MB/s
   ```

5. 将生成的img文件拷贝出来用于启动虚拟机

   sudo mkdir /mnt/share

   sudo mount - t vboxsf Kanbox /mnt/share

   前提：安装virtualBox的附件

6. 新建虚拟机，用img文件启动

## 进程 process

进程是操作系统最核心的概念

现代操作系统的一切都为进程而展开

进程是**正在运行的程序的一个抽象（正解）**

- 进程执行模型
  - 顺序执行（Sequential Mode）
  - 并发执行（Parallel Mode）

- 伪并行
  - 并行与并发

## 进程的执行模型

对应到操作系统当中，进程的执行模型同样有**顺序执行**和**并行执行**。

顺序执行：一个进程执行完毕，再紧接着执行另外一个进程

![One program counter](img\One program counter.png)

缺点：执行效率太低

并行执行：四个进程同时执行，相互独立，互不干扰

![Four program Counters](img\Four program Counters.png)

缺点：硬件要求太高

### 进程的并发执行模型

**并发(concurrence)执行是微观上的顺序执行，宏观上的并行执行**

 并发

![进程并发执行模型示意图](img\进程并发执行模型示意图.png)

有两个程序A和B共享一个变量N，初始值为5

A A1:N=N+1

B B1: Print(N)

​    B2: N=0;

不同的执行顺序，会产生不一样的结果

## 进程的状态

![两状态进程模式图](img\两状态进程模式图.png)

进程的三种基本状态

- **就绪（Ready）状态**：当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。

- **执行状态（Running）**：进程已获得CPU，其程序正在执行。

- **阻塞状态（Blocked）**：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，把这种暂停状态称为阻塞状态，有时也称为等待状态。

````mermaid
graph RL
a((就绪)) --进程调度--> b((执行))
b --请求资源--> c((阻塞))
c --请求得到满足--> a
b --时间片用完-->a
````

单阻塞队列

![单阻塞队列](img\单阻塞队列.png)

多阻塞队列

![多阻塞队列](img\多阻塞队列.png)

多阻塞队列可以分类请求，分别处理，只需要检测CPU请求的队列

New：进程已经创建，但未被OS接纳为可执行进程，并且程序还在辅存，PCB在内存

Exit：因停止或取消，被OS从执行状态释放

```mermaid
graph LR
a(New) --Admit--> b(Ready)
b --Dispatch--> c(Running)
c --Release--> d(Exit)
c --Event Walt--> e(Blocked)
e --Event Occurs--> b
c --Timeout--> b
```

### 进程的挂起状态

挂起状态：使执行的进程暂停执行,静止下来,我们把这种静止状态称为挂起状态。

| 事件           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 交换           | 操作系统需要释放足够的内存空间，以调入并执行处于就绪状态的进程 |
| 其他OS原因     | 操作系统可能挂起后台进程或工具程序进程，或者被怀疑导致问题的进程 |
| 交互式用户请求 | 用户可能希望挂起一个程序的执行，目的是为了调试或者与一个资源的使用和连接 |
| 定时           | 一个进程可能会周期性地执行（例如记账或系统监视进程），而且可能等待下个时间间隔时挂起 |
| 父进程请求     | 父进程可能会希望挂起后代进程的执行，一检查或修改挂起的进程，或者协调不同后代进程之间的行为 |

引入了挂起状态

![含有挂起态的进程状态转换图](img\含有挂起态的进程状态转换图.png)

- 空白→新建：系统调用、用户登陆、用户请求……
- 新建→就绪：系统尚有空余资源，接纳进程并放入就绪队列

- 就绪→运行：获得了除了CPU之外的所有资源

- 运行→完毕：进程正常执行完毕或者被KILL

- 运行→就绪：时间片用完、CPU被抢占

- 运行→阻塞：等待请求完成

- 阻塞→就绪：请求已经完成

- 就绪（阻塞）→退出：无偿地被KILL

- 阻塞→阻塞挂起：释放内存空间

- 就绪→就绪挂起：没有阻塞进程，挂起就绪进程以释放空间

- 就绪挂起→就绪：没有就绪进程或者就绪进程优先级较低

- 阻塞挂起→阻塞

- 阻塞挂起→就绪挂起

## 进程的控制

- 进程状态（若干状态之间的转换及转换依据）

- 进程映像
  - 进程的程序、数据、堆、栈的集合

- 进程控制块 PCB （Process Control Block）
  - 用于控制进程属性的集合

- 进程图

![General Structure of operating system control tables](img\操作系统控制表的一般结构.png)

primary process table中就是进程映像，Process Image中的进程也会和其他tables有交互

**进程控制块**

| PCB存储信息 | 内容和功能（p87)                                  |
| ----------- | ------------------------------------------------- |
| 标识符      | PID和进程名称（名称会重复） Win:>tasklist可以查看 |
| 状态        |                                                   |
| 优先级      |                                                   |
| 程序计数器  | 下一条执行指令的地址                              |
| 内存指针    | 程序代码和进程相关数据指针、共享内存块指针等      |
| 上下文      | 处理器的寄存器数据信息                            |
| IO状态      | 处理器的使用时间总和、时间限制等，设备状态        |
| 审计信息    | 执行时间，使用资源。供操作系统参考和参考          |

进程标识

- 标识符

处理器状态信息

- 用户可见寄存器，控制和状态寄存器，栈指针

进程控制信息

- 调度和状态信息，进程间通信，特权、存储管理、资源使用情况

![进程的组成](img\进程的组成.png)

- 操作系统维持着一个由PCB组成的链表，根据链表中的PCB来控制系统中的进程
- 进程控制块面临的难题——安全保护
  - 病毒会不出现在PCB中，或修改其他进程

**进程图 Process Graph**

进程图是用于描述一个进程的家族关系的有向树。

**子进程**可以继承**父进程**所拥有的资源。

当子进程被撤消时，应将其从父进程那里获得的资源归还给父进程。 

思考：父进程死掉，子进程怎么办？

#### 进程的创建 Process Creation

Events which cause process creation:

- 系统初始化 System initialization.

- 正在运行的进程调用了一个进程创建系统

  Execution of a process creation system call by a running process.

- 用户请求 A user request to create a new process.

- 批处理作业的初始化 Initiation of a batch job.

分配一个唯一进程标识符，分配相应空间（包括进程映像所以元素）

调用进程**创建原语**按下述步骤创建一个新进程：

1. 申请空白PCB。  

2. 为新进程分配资源。为新进程的程序和数据以及用户栈分配必要的内存空间。

3. 初始化进程控制块。
   - 初始化标识信息。
   - 初始化处理机状态信息。使程序计数器指向程序的入口地址，使栈指针指向栈顶；
   - 初始化处理机控制信息：进程的状态、优先级。

4. 将新进程插入就绪队列。

关于Unix和Windows的不同做法

- Unix：fork()

- 创建一个和调用进程相同的副本。
  - 相同的存储映像、相同的环境……

- 子进程执行execve修改存储映像

#### 进程终止 Process Termination

Events which cause process termination:

- Normal exit (voluntary).

- Error exit (voluntary).

- Fatal error (involuntary).

- Killed by another process (involuntary).

利用**终止原语**(原子操作，不可再分)终止进程

- 检索将被终止的进程PCB

- 终止该进程的执行（若有子进程，一并终止）

- 回收资源

- 将该进程PCB从当前队列中移除

#### 进程的阻塞

调用**阻塞原语**自我阻塞

自我阻塞，所以阻塞是发生在运行过程中。会插入到不同的阻塞队列中

- 暂停进程的执行，修改PCB运行状态

- 将PCB插入阻塞队列

- 调度新进程

#### 进程的唤醒

调用**唤醒原语**唤醒进程

- 检索阻塞队列，寻找要唤醒进程的PCB

- 修改PCB的运行状态

- 插入PCB到就绪队列

#### 进程的挂起与激活

利用**挂起原语**挂起进程

利用**激活原语**激活进程

### 进程的切换

步骤

- 保存处理器状态信息

- 更新当前进程的状态

- 将当前进程PCB移动到相应的队列

- 选择另一个进程PCB

- 更新该进程的PCB

- 更新内存管理的数据结构

- 恢复当前进程被切换前的上下文信息

### 模式切换

模式切换可以不改变正处于运行态的进程的状态。

​	进程切换会导致模式切换，反之不一定改变

​	如：使用内心功能，进程发出系统调用请求，进程一直处于执行状态；当系统调用为IO处理时，进程状态会变成阻塞状态

保存上下文环境和恢复上下文环境只需要很小的开销

## 线程 Threads

回顾进程的概念

- 每个进程有自己独立的地址空间

- 每个进程拥有自己资源的控制权
  - I/O、主存、文件……
- 进程是操作系统的最小调度单位
  - 进程切换

为了减少操作系统的开销，现代操作系统引入线程的概念

线程是调度的最小单位

进程是资源拥有的最小单位

一个进程可以有多个线程

组合方式：单进程单线程	单进程多线程	多进程单线程	多线程多进程

线程的特点

- 同一个进程的所有线程共享该进程的资源

- 同一个进程的所有线程共享同一个地址空间

线程的优点

- 创建快（比进程大约快10倍）（在进程的资源基础上创建）

- 终止快（线程终止不需要被回收）

- 切换快（一般在进程内部切换，保存信息较少）

- 通信快，无需内核介入

![线程进程模型](img\线程进程模型.png)

在支持线程的操作系统中，线程是调度分派的最小单位，进程是资源拥有的最小单位

线程同样具有几种基本状态

- 就绪、执行、阻塞

同样存在进程的调度

对进程的操作影响到进程中的所有线程

**线程的基本操作**

- 派生（Spawn)：当产生一个新进程时，同时也为该进程派生了一个线程，随后，进程中的线程可以在同一个进程中派生另一个线程，新线程被放置在就绪队列中。

- 阻塞（Block)：当线程需要等待一个事件时，它将阻塞，此时处理器转而执行另一个就绪线程。

- 解除阻塞（Unblock）：当阻塞一个线程的事件发生时，该线程被转移到就绪队列中。

- 结束（Finish）：当一个线程完成时，其寄存器的信息和栈都被释放。

- 线程的实现
  - 用户级线程
    - 线程的管理由应用程序完成
  - 内核级线程
    - 线程的管理由内核完成，应用程序通过API访问线程

![用户级线程和内核级线程](img\用户级线程和内核级线程.png)

a. 用户级线程，操作系统感知不到线程存在，只知道进程存在。信息交换只在用户空间完成

b. 内核级线程，调用API完成，操作系统可以感知到。用户控件不能完成信息交换，需要调用API在内核完成信息交换，需要模式切换有较大开销。

**用户级线程**与内核级线程的比较

- 用户级线程不需要模式切换（由应用程序完成）

- 用户级线程由应用程序实现调度管理

- 用户级线程可以在任意操作系统中运行（语言提供用户级线程库）

**缺点**

- 用户级线程执行系统调用时，同一进程所有线程都会被阻塞

- 不能利用多处理机技术

用户级线程与**内核级线程**的比较

- 内核实现内核级线程的调度管理

- 可以充分利用多处理机技术

**缺点**

- 有模式切换的开销

## 进程的并发

并发是所有问题的基础，也是操作系统设计的基础

由并发带来的两个问题

- 对资源的相互制约：同步

- 对资源的相互共享：互斥

### 相关的关键概念

- 临界资源：一次仅允许一个进程访问的资源为临界资源

- 临界区
  - 把在每个进程中访问临界资源的那段**代码**称为临界区
  - 代码作为一个共享资源，一次只能允许一个进程访问

- 死锁：两个或两个以上的进程相互等待导致都不能执行

- 活锁：由于某些条件不满足，导致进程不断重复尝试而不能正常推进执行

- 互斥：当一个进程在临界区访问临界资源时，其他进程不能进入该临界区访问共享资源

- 竞争：多个进程读写一个共享数据时依赖它们执行的相对时间
  - 竞争条件发生在多个进程或线程读写数据时，其最终结果取决于多个进程的指令执行顺序

- 饥饿：一个进程得不到执行机会（P134）

合作关系：直接知道（直接通信），间接知道（通过共享）

进程的并发会导致程序执行结果不封闭

- 全局资源

  对全局资源的访问秩序非常重要

- 资源分配

  不好的分配算法可能导致死锁

为了实现对临界资源的访问，每个进程都**互斥**地进入自己的临界区：**一次只有一个程序在临界区**

1. 进入临界区之前，对预先访问的临界资源进行检查

2. 若该资源尚未被访问，则可以进入临界区；反之则不能

3. 设置正在访问标志

最后，将资源恢复为未访问标志

### 互斥可能带来的问题

- 死锁：进程P1占有资源R1，等待资源R2；进程P2占有资源R2，等待资源R1

- 饥饿：无限期地被推迟访问

#### 同步机制应该遵循的准则

1. **空闲让进**
2. **忙则等待**
3. **有限等待**
4. **让权等待**

#### 实现互斥访问

- 严格轮换

​	每个进程每次都从头执行到尾

- 屏蔽中断

​	刚刚进入临界区时就屏蔽中断，刚要出临界区就打开中断

- 专用机器指令

​	test_and_set、test_and_clear 

- 软件方法

​	信号量

### 软件方法解决互斥与同步

算法分析（ Dekker’s Algorithm ）

```c
Int turn=0; //共享的全局变量
Process 0
{
    while turn≠0 do {nothing};
    <critical section>;
    turn=1;
}
Process 1
{
    while turn ≠ 1 do {nothing};
    <critical section>;
    turn=0;
}
```

解析：保证了互斥，但存在问题：进程“忙等”进入临界区；若黑板标志修改失败，其他进程**永久阻塞**

-------

```c
boolean flag[2]; //共享的全局变量
Process 0
{
    while flag[1] do {nothing};
    flag[0]=true;
    <critical section>;
    flag[0]=false;
}
Process 1
{
    while flag[0] do {nothing};
    flag[1]=true;
    <critical section>;
    flag[1]=false;
}
```

若进程执行完临界区，恢复自己标志为“false”失败，则其他进程永久阻塞。

-------

在检查其他进程之前，希望进到临界区，则设置自己 flag=true。

当设置标志为真后，如果其他进程在临界区，则本进程阻塞，直到其他进程释放临界区为止。

```c
var flag : array [0，1] of boolean :false ;
Process 0
{
    flag[0]=true;
    while flag[1] do {nothing};
    <critical section>;
    flag[0]=false;
}
Process 1
{
    flag[1]=true;
    while flag[0] do {nothing};
    <critical section>;
    flag[1]=false;
}
```

如果两个进程在执行while之前都把flag设置成true，那么每个进程都会以为对方进入了临界区，使自己处于阻塞，从而导致死锁。

-------

主要思想是将标志重置，不会发生死锁。

实现过程：

- 希望进到临界区，则设置自己 标志为：flag=true。

- 如果其他进程在临界区，则将本进程标志置为flag=false，稍后又置为true，这一过程重复到能进入临界区为止。