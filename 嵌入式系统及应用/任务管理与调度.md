# 任务管理与调度

![Splitting an application into Tasks](img\Splitting an application into Tasks.png)

```c
int main(void)
{
     // Initialize uCOS-II.
    OSInit();
    // Create the first task
    OSTaskCreate(TestTask1, (void *) 11, &TestTaskStk1[TASK_STK_SIZE], 11);
    // Start multitasking.
    OSStart();
    return 0;
}

void TestTask1(void *pdata)
{   printf("%4u: ***** Test Task 1 First call *****\n", OSTime);

    //Create 3 other tasks
    OSTaskCreate(TestTask2, (void *) 22, &TestTaskStk2[TASK_STK_SIZE], 22);     
    OSTaskCreate(TestTask3, (void *) 33, &TestTaskStk3[TASK_STK_SIZE], 33);
    OSTaskCreate(TestTask4, (void *) 10, &TestTaskStk3[TASK_STK_SIZE], 10);

    while (1)
    {   
        printf("%4u: ***** Test Task 11 *****\n", OSTime);
        OSTimeDly(1);                                                           
    }
}
void TestTask2(void *pdata)
{   
    while (1)
    {   printf("%4u: ***** Test Task 22 *****\n", OSTime);

        OSTimeDly(1);
    }
}

void TestTask3(void *pdata)
{   
    while (1)
    {
        printf("%4u: ***** Test Task 33 *****\n", OSTime);
        OSTimeDly(1);
    }
}

void TestTask4(void *pdata)
{   
    while (1)
    {
        printf("%4u: +++++ Test Task 10 +++++\n", OSTime);
        OSTaskSuspend(10); //Suspend yourself

    }
}
```

 采用多任务的好处

- 任务的**规模较小**

  每个任务更容易编码和调试，其质量也更容易得到保证

- 不少**应用本身**就是由多个任务构成的

  如一个应用可能需要进行以下任务的处理：计算、从网络获取数据和刷新显示屏幕

  采用多任务的处理方式是应用问题的一个非常自然的解决方式

- 任务之间具有较高的独立性，耦合性小

  通过增加新的任务就能方便的**扩充系统功能**

- **实时性强**

  保证紧急事件得到优先处理成为可能

在嵌入式实时系统中

- 任务（task）通常为进程（process）和线程（thread）的统称

- 任务是调度的基本单位

进程最初由Multics的设计者在60年代提出来的，主要包括以下内容 

- 一个正在执行的程序；

- 计算机中正在运行的程序的一个实例；

- 可以分配给处理器，并由处理器执行的一个实体；

- 由一个顺序的执行线程、一个当前状态和一组相关的系统资源所刻画的活动单元。

进程由**代码、数据、堆栈**和**进程控制块**构成

- 进程控制块包含了操作系统用来控制进程所需要的信息：
  - 进程状态
  - CPU寄存器
  - 调度信息
  - 内存管理信息
  - I/O状态信息等

早期的进程，包含了以下两个方面的内容 

- 资源。进程是资源分配的基本单位，一个进程包括一个保存进程映像的虚拟地址空间、主存、I/O设备和文件等资源。

- 调度执行。进程作为操作系统的调度实体，是调度的基本单位。

随着操作系统的发展，进程所包含的两个方面的内容逐渐被分开

- 轻量级进程或线程：调度执行的单位

- 进程：资源分配的单位
  - 线程是进程内部一个相对独立的控制流，由线程上下文和需要执行的一段程序指令构成
  - 在进程中，所有线程共享该进程的状态和资源，可以访问相同的数据

使用线程的优势

- 创建：在一个已有进程中创建一个新线程比创建一个全新的进程所需的时间开销少；
- 终止：终止一个线程比终止一个进程所花费的时间少；
- 切换：线程切换比进程切换所花费的时间少；
- 通信：使同一进程内部不同线程之间的通信效率得到显著提高。

在大多数操作系统中，不同进程之间的通信需要内核的干预，而同一进程内部不同线程之间则可直接通信。  

大多数嵌入式实时内核：**单进程/多线程**模型，或简单地称为**任务模型**

- 把整个应用当作一个没有定义的进程来对待；

- 应用则被划分为多个任务的形式来进行处理。

- 适用于实时性要求较高的、相对简单的应用

也有一些嵌入式实时操作系统采用了**多进程/多线程**模型：

- 系统中包含多个进程，每个进程对应又包含多个线程

- 适合于处理复杂的应用

## 任务

任务是一个具有**独立功能**的**无限循环**的程序段的一次运行活动，是实时内核调度的单位，具有以下特性

- 动态性：任务状态是不断变化的
  - 一般分为**就绪态、运行态和等待态**。
  - 在多任务系统中，任务的状态将随着系统的需要不断进行变化。
- 并行性
  - 系统中同时存在多个任务，这些任务在宏观上是同时运行的。
- 异步独立性
  - 每个任务各自按**相互独立**的**不可预知**的速度运行，走走停停。 

### 任务内容

任务主要包含以下内容 

- 代码：一段可执行的程序

- 数据：程序所需要的相关数据（变量、工作空间、缓冲区等）

- 堆栈

- 程序执行的上下文环境

```c
void YourTask (void *pdata){
    /* USER CODE */
    OSTaskDel(OS_PRIO_SELF);//转到休眠状态
}
OSTaskCreate(TestTask1, (void *)11,&TestTaskStk1(TASK_STK_SIZE),11);//这里的11是用户自定义的数字可以不一样，这里引用了函数指针和指明了使用的堆栈
```

任务与程序的区别 

- 任务能真实地描述工作内容的并发性，而程序不能；

- 程序是任务的组成部分
  - 除程序外，任务还包括数据、堆栈及其上下文环境等内容；

- 程序是静态的，任务是动态的；

- 任务有生命周期，有诞生、有消亡，是短暂的；而程序是相对长久的；

- 一个程序可对应多个任务，反之亦然；

- 任务具有创建其他任务的功能，而程序没有。 

任务上下文环境（context）

- 包括了实时内核**管理任务**、以及处理器**执行任务**所需要的所有信息。
  - **任务优先级**
  - **任务的状态**等实时内核所需要的信息
  - 以及处理器的**各种寄存器的内容（hardware context）**：程序计数器、堆栈指针、通用寄存器等的内容

- 任务的上下文环境通过**任务控制块**（Task Control Block，TCB）来体现。

按照到达情况的可预测性，任务可以划分为

- 周期任务（periodic task）：周期任务每隔一个固定的时间间隔就会执行一次

- 非周期任务：非周期任务执行的间隔时间则为不确定的
  - sporadic task：有最小到达间隔时间限制
  - aperiodic task：没有到达时间限制

按照重要程度，可分为

- 关键任务（critical task）：为需要得到**及时执行**的任务，否则将出现灾难性的后果

- 非关键任务（noncritical task）：如果没有得到及时执行，则不会产生严重后果 

### 任务参数

- 优先级（priority）

- 周期（period）

- 计算时间（computation time）

- 就绪时间（ready time）

- 截止时间（deadline）

#### 任务优先级

表示任务对应工作内容在处理上的优先程度

优先级越高，表明任务越需要得到优先处理

任务的优先级分为静态优先级和动态优先级。

静态优先级：任务的优先级被确定后，在系统运行过程中将不再发生变化；

动态优先级：系统运行过程中，任务的优先级是可以动态变化的。 

#### 周期

周期任务所具有的参数，表示任务周期性执行的间隔时间

#### 任务的计算时间

任务在**特定硬件环境下**被完整执行所需要的时间，也被称为是**任务的执行时间**（execution time）

由于任务每次执行的软件环境的差异性，导致任务在各次具体执行过程中的计算时间各有不同

通常用**最坏情况下的执行时间**（worst case time）或是需要的最长执行时间来表示，也可用**统计时间**（statistical time）来表示

#### 任务的就绪时间

任务具备了在处理器上被执行所需要条件时的时间。 

#### 任务的截止时间

意味着任务需要在该时间到来之前被执行完成。

截止时间可以通过**绝对截止时间**（absolute deadline）和**相对截止时间**（relative time）两种方式来表示

- 相对截止时间为任务的绝对截止时间减去任务的就绪时间。

截止时间可以分为**强截止时间**（hard deadline）和**弱截止时间**（soft deadline）两种情况：

- 具有强截止时间的任务即为**关键任务**，如果截止时间不能得到满足，就会出现严重的后果。

- 拥有关键任务的实时系统又被称为**强实时**（hard real-time）系统，否则称为**弱实时**（soft real-time）系统。 

## 任务管理

### 任务状态与变迁

任务拥有的**资源情况**是不断变化的，导致**任务状态**也表现出不断变化的特性。

不同的实时内核实现方式对任务状态的定义不尽相同，但是都可以概括为三种基本的状态：

- 等待（waiting）：任务在等待某个事件的发生；

- 就绪（ready）： 任务等待获得处理器资源；

- 执行（running）：任务获得处理器资源，所包含的代码内容正在被执行。 

在单处理器系统中：

- 任何时候都**只有一个任务在CPU中执行**
  - 如果没有任何事情可做，就运行**空闲任务**执行空操作
- 任何一个可以执行的任务都必须处于**就绪状态**
  - 调度程序从任务的**就绪队列**中选择下一个需要执行的任务。
  - 处于就绪状态的任务拥有除CPU以外的其他所有需要的资源。
- 任务还可能处于**等待状态**
  - 如果任务在需要等待I/O设备或其他任务提供的数据，而数据又还没有到达该任务的情况下，就处于等待状态

任务会在不同的状态之间进行转换，即任务状态的变迁

```mermaid
graph RL
a(就绪态)--获取CPU-->b(运行态)
b--被搞优先级任务抢占或超时-->a
b--需要资源-->c(等待态)
c--获取资源-->a

```

![三个任务进行状态转换的过程](img\三个任务进行状态转换的过程.png)

包含三个任务和一个调度程序。调度程序用来确定下一个需要投入运行的任务，因此**调度程序本身也需要占用一定的处理时间**。

#### uCOS 的状态转换

![Task states and transition of uCOS](img\Task_states_and_transition_of_uCOS.png)

休眠态（DORMENT）该任务驻留在程序空间，但还没交给μC/OSⅡ管理。通过就绪链管理

就绪态（READY）任务为运行已经准备就绪，但由于该任务的优先级比正在运行的任务的优先级低，还暂时不能运行。

运行态（RUNNING）任务掌握了CPU的控制权，正在运行中。 

挂起态（WAITING）又称为等待事件态，指该任务在等待某一事件的发生，例如等待信号量、等待某共享资源由暂时不能使用变成能使用的状态等。

被中断态（ISR）当中断发生时，原来正在运行的任务暂时不能运行，就进入了该状态。

中断态，主要是由系统节拍click产生的

### 空闲任务

Which is executed when none of the other tasks is ready to run. 

The idle task is always set to the lowest priority. 

The idle task can never be deleted by application software. 

Idle Task is created by OS

```c
void  OS_TaskIdle (void *pdata)
{
    /* Prevent compiler warning for not using 'pdata‘ */
    pdata = pdata;  
    for (;;) 
    {
        OS_ENTER_CRITICAL();
        OSIdleCtr++; //记录这个值，计算CPU利用率
        OS_EXIT_CRITICAL(); //临界区
        /* Call user definable HOOK                   */
        OSTaskIdleHook(); 
    }
}
```

OSIdleCtr is used by the statistics task to determine how much CPU time (in percentage) is actually being consumed by the application software.

### 任务控制块

任务管理是通过对任务控制块（Task Control Block，TCB）的操作来实现的。 

**任务控制块是包含任务相关信息的数据结构**

- 包含了任务执行过程中所需要的所有信息。

任务控制块大都包括以下信息：

- 任务的名字

- 任务执行的起始地址

- 任务的优先级

- 任务的状态

- 任务的硬件上下文（堆栈指针、PC和寄存器等)

- 任务的队列指针等内容 

为节约内存，任务数量通常需要进行预先配置

- 按照配置的任务数量初始化任务控制块，一个任务对应一个初始的任务控制块，形成一个**空闲任务控制块链**。

在任务创建时，实时内核从空闲任务控制块链中为任务分配一个任务控制块。

- 随后对任务的操作，都是基于对应的**任务控制块**来进行的。

- 当任务被删除后，对应的任务控制块又会被实时内核回收到**空闲任务控制块链**。 

### 任务切换

任务切换（context switching）

- 保存当前任务的上下文，并恢复需要执行的任务的上下文的过程。

当发生任务切换时

- 当前正在运行的任务的上下文就需要通过该任务的任务控制块保存起来；

- 把需要投入运行的任务的上下文从对应的任务控制块中恢复出来。

![三个任务进行状态转换的过程](img\三个任务进行状态转换的过程.png)

在时刻8即发生了任务切换，任务1的上下文需要保存到任务1的任务控制块中去。

经过调度程序的处理，在时刻10任务2投入运行，需要把任务2的任务控制块中关于上下文的内容恢复到CPU的寄存器中。  

任务切换将导致任务状态发生变化

- 当前正在运行的任务将由**运行状态**变为**就绪或是等待**状态；

- 需要投入运行的任务则由**就绪状态**变为**运行状态**。

任务切换基本步骤

1 保存任务上下文环境

2 更新当前运行任务的控制块内容，将其状态改为就绪或等待状态

3 将任务控制块移到相应队列（就绪队列或等待队列）

4 选择另一个任务进行执行(调度)

5 改变需投入运行任务的控制块内容，将其状态变为运行状态

6 恢复需投入运行任务的上下文环境

任务切换时机

- 中断、自陷
  - 如当I/O中断发生的时候
    - 如果I/O活动是一个或多个任务正在等待的事件，内核将把相应的处于等待状态的任务转换为就绪状态
    - 同时，内核还将确定是否继续执行当前处于运行状态的任务，或是用高优先级的就绪任务抢占该任务
  - 自陷
    - 由于执行任务中当前指令所引起，将导致实时内核处理相应的错误或异常事件，并根据事件类型，确定是否进行任务的切换
- 运行任务因缺乏资源而被阻塞
  - 如，任务执行过程中进行I/O操作时（如打开文件），如果此前该文件已被其他任务打开，将导致当前任务处于等待状态，而不能继续执行
- 时机片轮转调度时
  - 内核将在时钟中断处理程序中确定当前正在运行的任务的执行时间是否已经超过了设定的时间片
  - 如果超过了时间片，实时内核将停止当前任务的运行，把当前任务的状态变为就绪状态，并把另一个任务投入运行
- 高优先级任务处于就绪时
  - 如果采用基于优先级的抢占式调度算法，将导致当前任务停止运行，使更高优先级的任务处于运行状态

```c
void OS_Sched (void)
```

Context-switch under 80x86

```assembly
_OSCtxSw    PROC   FAR
            PUSHA                                  ; Save current task's context
            PUSH   ES                              ;                                         
            PUSH   DS                              ;                                         
;
            MOV    AX, SEG _OSTCBCur             ; Reload DS in case it was altered
            MOV    DS, AX                          ; 
;
            LES    BX, DWORD PTR DS:_OSTCBCur      ; OSTCBCur->OSTCBStkPtr = SS:SP           
            MOV    ES:[BX+2], SS                   ; 
            MOV    ES:[BX+0], SP                   ; 
;
            CALL   FAR PTR _OSTaskSwHook                                                     
;
            MOV    AX, WORD PTR DS:_OSTCBHighRdy+2 ; OSTCBCur = OSTCBHighRdy                 
            MOV    DX, WORD PTR DS:_OSTCBHighRdy   ; 
            MOV    WORD PTR DS:_OSTCBCur+2, AX     ; 
            MOV    WORD PTR DS:_OSTCBCur, DX       ; 
;
            MOV    AL, BYTE PTR DS:_OSPrioHighRdy  ; OSPrioCur = OSPrioHighRdy               
            MOV    BYTE PTR DS:_OSPrioCur, AL            
;
            LES    BX, DWORD PTR DS:_OSTCBHighRdy 
;                                                    SS:SP = OSTCBHighRdy->OSTCBStkPtr 
            MOV    SS, ES:[BX+2]                   ; 
            MOV    SP, ES:[BX]                     ; 
;
            POP    DS                              ; Load new task's context                
            POP    ES                              ;                                        
            POPA                                   ;                                        
;
            IRET                                   ; Return to new task                     
;
_OSCtxSw    ENDP
```

## 任务调度

## 优先级反专