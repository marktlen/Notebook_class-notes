# 同步、互斥与通信

## 概述

多任务系统中任务之间/任务与ISR的关系

- 相互独立 仅竞争CPU资源
- 竞争除CPU外的其他资源（互斥）
- 同步 协调彼此运行的步调，保证协同运行的各个任务具有正确的执行次序 
- 通信 彼此间传递数据或信息，以协同完成某项工作

任务能以以下方式与中断处理程序或其他任务进行同步或通信：

- 单向同步或通信：一个任务与另一个任务或一个ISR同步或通信
- 双向同步或通信：两个任务相互同步或通信。双向同步不能在任务与ISR之间进行，因为ISR不能等待

在单处理器平台上，嵌入式操作系统内核提供的同步、互斥与通信机制主要包括：

- 互斥， 互斥信号量（mutex）
- 同步，信号量（semaphore）、事件（组）（Flag\event group）、异步信号（asynchronous signal）
- 消息通信，邮箱（mailbox）、消息队列（message queue）
- 非结构化数据交换和同步 ，管道（pipe）

以下一些机制也可用于同步与通信（在单处理器或多处理器系统中）

- 全局变量，共享内存，Sockets，远程过程调用（Remote Procedure Call），自旋锁

嵌入式多任务系统中，任务间的耦合程度是不一样的

- 耦合度：对任务之间关联程度的度量
- 耦合程度较高：任务之间需要进行大量的通信，相应的系统开销较大；
- 耦合程度较低：任务之间不存在通信需求，其间的同步关系很弱甚至不需要同步或互斥，系统开销较小

任务划分准则之一：耦合度高的模块尽量划分在同一任务内

## 信号量

这一部分可以查看操作系统

### 信号量的种类及用途

信号量用于实现任务与任务之间、任务与中断处理程序之间的同步与互斥。

互斥信号量：用于解决互斥问题。它比较特殊，可能会引起优先级反转问题。

二值信号量：用于解决同步问题

计数信号量：用于解决资源计数问题

### 互斥信号量

用互斥信号量保护的代码区称作“**临界区**”，临界区代码通常用于对**共享资源**的访问。**互斥信号量的值被初始化成1**，表明目前没有任务进入“临界区”，但最多只有一个任务可以进入“临界区”

共享资源可能是一段存储器空间、一个数据结构或I/O设备，也可能是被两个或多个并发任务共享的任何内容

使用互斥信号量可以实现对共享资源的串行访问，保证只有成功地获取互斥信号量的任务才能够释放它

互斥信号量是一种特殊的二值信号量，一般它支持**所有权、递归访问、任务删除安全**等概念和一些**避免优先级反转、饥饿、死锁等互斥所固有问题的协议**。

```mermaid
graph LR
初始化值为1 --> a(开启)
a --申请并获得值为0--> b(锁定)
b --释放值为1--> a
b --申请/释放 递归/递减 并获得锁定数加1/减1--> b
```

**所有权**：当一个任务通过获取互斥信号量而将其锁定时，得到该互斥信号量的所有权。相反，当一个任务释放信号量时，失去对其的所有权

当一个任务拥有互斥信号量时，其他的任务不能再锁定或释放它，即任务要释放互斥信号量，必须事前先获取该信号量

#### 嵌套（递归）资源访问

如果Task1调用RoutineA，而RoutineA又调用RoutineB，并且三者访问相同的共享资源，就发生了递归共享资源的访问同步问题

每个获取信号量的调用必须与释放信号量的调用相匹配

用于**同步的信号量不支持嵌套**访问

#### 删除安全

在一个受信号量保护的临界区，经常需要保护在临界区执行的任务不会被意外地删除

删除一个在临界区执行的任务可能引起意想不到的后果，造成保护资源的信号量不可用，可能导致资源处于破坏状态，也就导致了其它所有要访问该资源的任务无法得到满足

为避免任务在临界区执行时不被意外删除：

- 提供“任务保护”和“解除任务保护”原语对
- 同时，为互斥信号量提供“删除安全”选项。在创建信号量的时候使用这个选项，当应用每次获取信号量时**隐含**地使能“任务保护”功能，当每次释放信号量时隐含地使用“解除任务保护”功能。 

| 比较项目             | 关中断                                                       | 使用测试并置位指令                         | 禁止任务切换                                 | 使用信号量                                   |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| 锁定范围             | 互斥力度最强，锁定所有外部可屏蔽中断，凡是以中断形式到达的外部事件以及与之相关联的任务或处理过程均得不到执行 | 凡是使用该指令访问共享资源的代码           | 所以任务                                     | 只影响竞争共享资源的任务                     |
| 对系统响应时间的影响 | 如果关中断的时间较长，对系统的响应性能有很大影响             | 较小                                       | 如果禁止切换的时间过长，则影响系统的响应性能 | 对系统响应性能有一定影响，可能导致优先级反转 |
| 实现时的系统开销     | 小                                                           | 小                                         | 小                                           | 较大                                         |
| 注意事项             | 关中断时间要尽量短                                           | 不是所以处理器都具有这种指令，影响可移植性 | 关调度的时间要尽量短                         | 需采用一定的策略解决优先级反转问题           |

### 二值信号量

二值信号量主要用于任务与任务之间、任务与中断服务程序之间的同步

- 用于同步的二值信号量初始值为0，表示同步事件尚未产
- 任务申请信号量以等待该同步事件的发生
- 另一个任务或ISR到达同步点时，释放信号量（将其值设置为1）表示同步事件已发生，以唤醒等待的任务

### 计算信号量

计数信号量用于控制系统中共享资源的多个实例的使用，允许多个任务同时访问同一种资源的多个实例

计数信号量被初始化为n（非负整数），n为该种共享资源的数目

常用于生产者和消费者问题，mutex empty full

### 信号量机制的主要数据结构

![信号量机制的主要数据结构](同步、互斥与通信.assets/信号量机制的主要数据结构.png)

信号量控制块：管理所有创建的信号量，内核在系统运行时动态分配和回收信号量控制块

互斥和二值信号量控制块结构: Binary_Semaphore_Control_Block

- wait_queue 任务等待队列
- attributes 信号量属性
  - lock_nesting_behavior试图嵌套获得时的规则 
  - wait_discipline 任务等待信号量的方式（FCFS还是优先级等）
  - priority_ceiling 优先级天花板值
- lock 是否被占有
- holder 拥有者
- nest_count 嵌套层数

计数信号量控制结构Counting_Semaphore_Control_Block

- wait_queue 任务等待队列

- attributes 计数信号量属性

  - maximum_count    最大计数值

  - wait_discipline 任务等待信号量的方式

- count 当前计数值

#### 信号量内部实现机制实例说明 µC/OS-II

事件控制块ECB：同步与通信机制的基本数据结构

```c
typedef struct{
INT8U	OSEventType;//事件类型
INT8U	OSEventGrp;//等待任务所在的组 与等待任务列表是一对的
INT16U	OSEventCnt;//计数器（信号量）
void	*OSEventPtr;//指向消息或消息队列的指针
INT8U	OSEventTbl[OS_EVENT_TBL_SIZE];//等待任务列表
}OS_EVENT;
```

![事件控制块与任务等待列表关系](同步、互斥与通信.assets/事件控制块与任务等待列表关系.png)

当一个事件发生后，**等待事件**列表中优先级最高的任务（即在.OSEventTbl[]&OSEventGrp中所有被置1的位中优先级数值最小的任务）得到该事件

![等待事件列表](同步、互斥与通信.assets/等待事件列表.png)

当.OSEventTbl[n]中的任何一位为1时，OSEventGrp中的第n位为1。 与任务就绪列表类似！

将一个任务插入到等待事件的任务列表中 与将一个任务插入到就绪列表中的操作类似！

从等待事件的任务列表中使任务脱离等待状态 与将任务从就绪列表中清除的操作类似！

在等待事件的任务列表中查找优先级最高的任务 与查找优先级最高的就绪任务的操作类似！

空闲事件控制块，也是从空的结构里面选一个装入

```c
static void OS_InitEventList (void)
```

返回类型：无 参数：无

功能：初始化事件控制块ECB链，形成空闲ECB链表，所在文件os_core.c

### 典型的信号量操作

#### 创建信号量

功能：根据应用传递的参数创建一个信号量

参数：信号量的名字、属性和初始值等。

内核动作：

- 从空闲信号量控制块链中分配一个信号量控制块，并初始化信号量属性。
- 创建成功时，为其分配唯一的ID号返回给应用。
- 如果已创建信号量数量已达到用户配置的最大数量，就返回错误。

信号量的属性

- 信号量类型
- 任务等待信号方式
  - 先进先出
  - 优先级
- 优先级反转问题的解决方法（只适用于互斥信号量）
  - 优先级继承算法
  - 优先级天花板算法，需给出所有可能获得此信号量的任务中优先级最高的任务的优先级
  - 与任务删除安全、递归访问以及解决优先级反转的策略相关的参数

```c
OS_EVENT *OSSemCreate (INT16U cnt)
{
	OS_EVENT *pevent;
	pevent = OSEventFreeList;//从空闲事件控制块链中取得一个ECB
	if (OSEventFreeList != (OS_EVENT *)0) { 
	OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
	}
	if (pevent != (OS_EVENT *)0) { //初始化ECB的各个域
		pevent->OSEventType = OS_EVENT_TYPE_SEM; //事件类型为信号量
		pevent->OSEventCnt = cnt; //信号量的初始计数值
		pevent->OSEventPtr = (void *)0;
		OS_EventWaitListInit(pevent); //初始化等待任务列表
	}
	return (pevent); //调用者需检查返回值，如果为NULL则表示建立失败
}
```

#### 获取（申请）信号量

功能：试图获得应用指定的信号量。

- if   信号量的值大于0
- then  将信号量的值减1
- else  根据接收信号量的选项，将任务放到等待队列中，或是直接返回

当所申请的信号量不能被立即获得时，可以有以下几种选择：

- 永远等待
- 不等待，立即返回，并返回一个错误状态码
- 指定等待时限（可有效避免死锁）

注意：

- 不允许在ISR中选择等待
- 当任务选择等待时，将被按FIFO或优先级顺序放置在等待队列中

如果任务等待一个使用**优先级继承算法**的互斥信号量，且它的优先级高于当前正占有此信号量的任务的优先级，那么占有信号量的任务将继承这个被阻塞的任务的优先级。

如果任务成功地获得一个采用**优先级天花板算法**的互斥信号量，它的优先级又低于优先级天花板，那么它的优先级将被抬升至天花板。  

```c
//获取（等待）一个信号量
void OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
	if (pevent->OSEventCnt > 0) { //信号量值大于0，成功获得信号量并返回
		pevent->OSEventCnt--; 
		*err = OS_NO_ERR;
		return;} 
	OSTCBCur->OSTCBStat |= OS_STAT_SEM; //设置任务状态为等待信号量
	OSTCBCur->OSTCBDly = timeout; //设置等待时限
	OS_EventTaskWait(pevent);//将任务放置到信号量的等待列表中 
	OS_Sched(); //内核实施任务调度，系统切换到另一就绪任务执行
	if (OSTCBCur->OSTCBStat & OS_STAT_SEM) { //判断任务恢复执行的原因，如果等待时限超时但仍然未获得信号量，则返回超时信息
		OSEventTO(pevent); 
		*err = OS_TIMEOUT;
		return;}
	OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0; 
	*err = OS_NO_ERR; //任务由于获得信号量而恢复执行，本调用成功返回
}
//无等待地请求
INT16U OSSemAccept (OS_EVENT *pevent)
{
	INT16U cnt;
	cnt = pevent->OSEventCnt; 
	if (cnt > 0) { 
		pevent->OSEventCnt--; 
	}
	return (cnt); 
}
```

注意：即使不能成功获得信号量（返回值为0），调用者也不会被阻塞。此函数可以在中断处理程序中使用。

#### 释放信号量

功能：释放一个应用指定的信号量。 

- if   没有任务等待这个信号量
- then  信号量的值加1 
- else  将信号量分配给一个等待任务（将相应的任务移出等待队列，使其就绪） 

如果使用了优先级继承或优先级天花板算法，那么执行该功能（系统调用）的任务的优先级将恢复到原来的高度

```c
INT8U OSSemPost (OS_EVENT *pevent)
{
	if (pevent->OSEventGrp!=0x00) { //如果有任务在等待该信号量
		OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM); //使等待任务列表中优先级最高的任务就绪
		OS_Sched(); //内核实施任务调度
		return (OS_NO_ERR);//成功返回
	} 
	if (pevent->OSEventCnt < 65535) {//如果没有任务等待该信号量，并且信号量的值未溢出
		pevent->OSEventCnt++; //信号量的值加1
		return (OS_NO_ERR);//成功返回
	} 
	return (OS_SEM_OVF);//信号量溢出
}
```

#### 删除信号量

功能：从系统中删除应用指定的一个信号量

内核动作：将信号量控制块返还给系统

删除信号量的不一定是创建信号量的任务

**如果有任务正在等待**获得该信号量，执行此功能将使所有等待这个信号量的任务回到就绪队列中，且返回一个状态码指示该信号量已被删除

企图获取已删除的信号量将返回一个错误；

在互斥信号量正被使用时（已经被某任务获取），不能删除它。因为该信号量正在保护一个共享资源或临界代码段，该动作可能造成数据崩溃或其他严重问题。

```c
OS_EVENT *OSSemDel(OS_EVENT *pevent, INT8U opt, INT8U *err)
{
	BOOLEAN tasks_waiting;
	if(pevent->OSEventGrp!=0x00{//根据是否有任务在等待信号量设置等待标志
		tasks_waiting=TRUE;
	}else{
		tasks_waiting=FALSE;
	}
	switch(opt){
		case OS_DEL_NO_PEND://如果有任务等待信号量则不删除信号量
			if(task_waiting==FALSE{//没有任务等待，释放ECB回空闲链
				pevent->OSEventType=OS_EVENT_TYPE_UNUSED;
				pevent->OSEventPtr=OSEventFreeList;
				 OSEventFreeList=pevent;//调整空闲ECB链头指针
				*err=OS_NO_ERR;
				return((OS_EVENT)0);
			}else{	*err=OS_ERR_TASK_WAITING;//有任务等待，删除信号量失败
				return(pevent);
			}
		case OS_DEL_ALWAYS://无论有无任务等待都删除信号量
			 //将等待列表中的每个任务都设置成就绪
			while(pevent->OSEventGrp!=0x00){
			OS_EventTaskRdy(pevent,(void *)0, OS_STAT_SEM);}
			//释放该信号量的ECB回空闲控制块链
			pevent->OSEventType=OS_EVENT_TYPE_UNUSED;
			pevent->OSEventFreeList;
			 OSEventFreeList=pevent;
			//如果之前有任务等待信号量，内核实施任务调度
			if(tasks_waiting==TRUE){OS_Sched();}
			*err=OS_NO_ERR;
			return((OS_EVENT *)0);
		default:
			*err=OS_ERR_INVALID_OPT;
			return(pevent);
	}
}
```

#### 清除信号量的任务等待列表 

为了清除等待一个信号量的所有任务，某些内核支持Flush操作，以便释放信号量等待任务列表中的所有任务。当多个任务的执行必须在某些点相遇时，需要这样的机制。

```mermaid
graph LR
signalTask --Flush--> f[二值信号量初始值0]
f --> task1
f --> task2
```

## 邮箱和消息队列

### 通信方式概述

#### 直接通信

通信双方必须明确知道彼此  

Send (P，message) – 发送一个消息到任务P

Receive(Q，message) – 从任务Q接收一个消息

直接通信具有如下特性

- 每对任务之间仅存在一个链接
- 链接可以是单向，也可以是双向

#### 间接通信

通信双方不需要指出消息的来源或去向，通过中间机制通信。

send(A，message) – 发送一个消息给邮箱A

receive(A，message) – 从邮箱A接收一个消息

间接通信具有如下特性

- 只有当任务共享一个公共邮箱时链接才建立

- 一个链接可以与多个任务相联系
- 每个任务可以使用几个通信链接

消息：**内存空间中一段长度可变的缓冲区**，其长度和内容均可以由用户定义，其内容可以是实际的数据、数据块的指针或空

消息队列：属于**间接通信方式**

消息机制在任务之间、任务和ISR（中断服务程序）之间提供**消息传递或同步**

对消息内容的解释由应用完成

- 从**操作系统**观点看，消息没有定义的格式，所有的消息都是字节流，没有特定的含义。
- 从**应用**观点看，根据应用定义的消息格式，消息被解释成特定的含义。
- 应用可以只把消息当成一个标志，这时消息机制用于实现**同步**

一些操作系统内核把消息进一步分为：邮箱和消息队列

- 邮箱仅能存放**单条**消息，它提供了一种低开销的机制来传送信息。每个邮箱可以保存一条大小为若干个字节的消息(ucosIII 取消)
- 消息队列可存放**若干**消息，提供了一种任务间缓冲通信的方法。

消息机制可支持**定长与可变长度**两种模式的消息，可变长度的消息队列需要对队列中的每一条消息增加**额外的存储开销**

创建邮箱             OSMboxCreate

删除邮箱             OSMboxDel

申请消息             OSMboxPend

发送消息             OSMboxPost

申请消息（不带阻塞） OSMboxAccept

获取邮箱信息         OSMboxQuery

OS_EVENT *OSMboxCreate (void *pmsg)

### 消息队列机制的主要数据结构

![消息队列及其相关的参数和支持数据结构](同步、互斥与通信.assets/消息队列及其相关的参数和支持数据结构.png)

```mermaid
graph LR
a[空 队列创建消息数为0] --消息发送信息位1--> b[非空]
b --信息发送消息数加1--> b
b --消息发送信息素等于队列长度--> c[满]
c --消息接收数减1--> b
b --消息接收消息数减1--> b
b --消息接收消息数为0--> a

```

消息队列控制块

- 管理所有创建的消息队列，系统运行时动态分配和回收消息队列控制块

消息队列缓冲区

- 存放发送到该队列的消息，接收者从缓冲区中取出消息
- 消息的发送或接收有两种方法（影响消息缓冲区结构）
  - 将数据从发送任务的空间**完全拷贝**到接收任务的空间中（效率较低，执行时间与消息大小有关）
  - 只传递指向数据**存储空间的指针**（提高系统性能，一般情况）

![消息队列的内存区域](同步、互斥与通信.assets/消息队列的内存区域.png)

发送和接收消息的消息拷贝和内存使用

- 这种消息传递方法效率低、占用空间大
- 一种效率更高的方式是传递消息指针

| 消息队列控制块    | 消息队列缓冲区（环形缓冲） |
| ----------------- | -------------------------- |
| wait_queue        |                            |
| max_message_count |                            |
| numer_of_message  |                            |
| wait_descipline   |                            |
| queue_state       | 队头                       |
| queue_in          | 消息头 指向message         |
| queue_out         | 消息尾                     |
| queue_end         | 队尾                       |

queue_in~out：number_of_message

queue_start~end：max_message_count

```c
typedef struct os_q {         /* QUEUE CONTROL BLOCK */
   struct os_q   *OSQPtr;      /* 空闲链表中当next指针使用  */
    void         **OSQStart;     /* 消息队列缓冲区的起始地址 */
    void         **OSQEnd;       /* 消息队列缓冲区的结束地址 */
    void         **OSQIn;          /* 放消息的指针  */
    void         **OSQOut;       /* 取消息的指针 */
    INT16U      OSQSize;       /* 消息队列缓冲区的容量 */
    INT16U      OSQEntries;     /* 当前放置在消息队列缓冲区中的消息数目  */
} OS_Q;
```

消息队列机制即要用到ECB，还要用到QCB

### 典型的消息队列操作

### 消息队列的其他典型使用

## 事件

## 异步信号*