# 文件IO

- 文件基本操作，打开、定位、读写、关闭
  - fopen和open，C库fopen有功能扩展

- IO效率

- 文件共享(必考)

- 其他重要IO函数

## 文件操作基本顺序

- 打开 open

- 创建 creat

- 定位 lseek

- 读 read

- 写 write

- 关闭 close

### open函数

用于打开或者创建一个文件

函数原型

```c
#include<fcntl.h>
int open(const char* pathname, int oflag, ...)
    //打开或创建的文件名，用于指定文件打开模式、标志等信息
    //需要前赋予文件权限，Linux的9个权限
```

#### oflag

- Linux头文件已经为文件打开模式、标志等定义了若干的宏

- oflag需要指定这些宏

- 宏定义在/usr/include/bits/fcntl.h中

- 在该头文件中，只读打开标志被定义为

- #define O_RDONLY  00

- 文件打开模式标志

  ​	以下三个标志必须指定一个且只能指定一个

  - O_RDONLY ： 只读打开

  - O_WRONLY ： 只写打开

  - O_RDWR   ： 读写打开

- 其他文件标志

   下面的标志是可以选择的，可通过C语言的或运算与文件打开标志进行组合

  - O_APPEND：每次写的数据都添加到文件尾

  - O_TRUNC：若此文件存在，并以(权限)读写或只写打开，则文件长度为0

  - O_CREAT：若文件不存在，则创建该文件。此时，open函数需要第三个参数，用于指定该文件的访问权限位

  - O_EXCL：若同时指定了O_CREAT标志，而文件已经存在，则会出错。可用于测试文件是否存在

返回值

- 整数数据
  - 成功时，返回文件描述符
  - 出错时，返回-1

文件描述符

- Window时返回文件句柄，是同一个描述
- 文件描述符：已打开文件的索引-->通过通过索引找到已打开文件

### 进程打开文件的内核数据结构

![进程打开文件](img\进程打开文件.png)

子进程会复制父进程fd_arrag数组

VFS抽象文件系统，方便文件系统与系统进行对接。

task-struct的files可以但不一定共用，不一定每一个进程有files_struct甚至会共享

从fd数组（已打开文件表）里面找到一个没有表项的数组项

读取文件描述符，找到PCB，取出已打开文件表files，读出file结构体

找到dentry（目录项）找到inode(索引节点)

file里面的flag是两个字段，存放open时的标志

进程创建时，创建了task_strct和files_struct的链接

#### 索引节点

- 文件系统索引节点的信息，存储在磁盘上
- 当需要时，调入内存，填写VFS的索引节点（即inode结构）
- 每个文件都对应了一个索引节点
- 通过索引节点号，可以唯一的标识文件系统中的指定文件

```c
struct inode{
    //...
    unsigned long i_no;	// 索引节点号
    umode_t i_mode;	// 文件类型访问
    uid_t i_uid;	//文件拥有者ID
    gid_t i_gid;	//文件拥有者所在组ID
    off_t i_size;	//文件大小
    time_t i_atime;	//文件最后访问时间
    time_t i_mtime;	//文件最后修改时间
};
```

元数据：描述性数据

#### 文件描述符

open函数返回的文件描述符已打开文件表的索引

文件描述符是已打开文件的索引，通过该值可以在fd_array表中检索相应的文件对象

文件描述符是一个非负的整数

文件描述符0、1、2分别对应于标准输入、标准输出、标准出错，在进程创建时，已经打开。

### 程序演示 open函数

出错处理(2.1)

errno.h头文件中，定义了errno：当API调用出错时，errno说明出错的具体原因

可简单地将errno理解成整型数据

出错信息转换成可读字符串

```c
#include<string.h>
char* strerror(int errno);
```

示例2.2

```c
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <iostream>

using namespace std;

int main()
{
  int fd = open("a.txt", O_RDONLY);
  if(-1 == fd)
  {     
    cout << "open error" << endl;
    cout << strerror(errno) << endl;
  }
  
  return 0;
}
```

以前的定义：extern int errno;

多线程环境：

```c
extern int * __errno_location();
#define errno (*__errno_location())
#Win: GetLastError()
```

perror函数

- perror函数根据当前的errno，输出一条出错信息

函数原型

```c
#include<stdio.h>
void perror(const char* msg);
```

示例2.3

```c
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <iostream>

using namespace std;

int main()
{
  int fd = open("a.txt", O_RDONLY);
  if(-1 == fd)
  {     
    cout << "open error" << endl;
    perror("test3");
  }
  
  return 0;
}

```

该函数输出：

msg指向的字符串: errno对应的出错信息

## creat函数

用于创建一个新文件

函数原型

 int creat(const char *pathname, mode_t mode)

参数

- pathname：要创建的文件名（包括路径信息）

- mode：同open的第三个参数，讨论文件的访问权限位时分析

返回值

- 成功返回**只写打开**的文件描述符
- 出错返回-1

creat函数的功能可以用open函数实现

   open(pathname,

​     O_WRONLY | O_CREAT | O_TRUNC,  

​     mode);

为什么需要指定O_TRUNC标志

当文件存在时，调用creat函数，会将文件的大小变为0

示例2.2

```c
#include<iostream>
#include<fcntl.h>
#include<unistd.h>
#include<sys/types.h>

using namespace std;

int main()
{    
  int fd = creat("a.txt", S_IRWXU);
  
  return 0;
}
```



------

**如何提升读取性能**

在cache的帮助下数组的读取5ns，cache会自动完成后面的读取，但链表无法完成。使用位向量减少内存表象，一个bit对应一个表象。

把Key/Value放同一个数组，可以用cache line提升访问速度。会直接命中

**Linux进程**

Linux中线程是一种进制，只是共用同一个页表

**TLS（Thread Local Storage）线程局部存储的实现**

第一种

​	假设最多支持8个线程。tid = GetTLS.TId()，no = tid %8

第二种

段基址+偏移量=线性地址

GS段和FS段的段基址不是零，每个线程都有自己的FS段

&errorno取地址操作取的是都是偏移量，除了GS段和FS段外

如：

​	T1 base = 1000 error:80

​	T2 base = 2000 error:80

​	T3 base = 3000 error:80