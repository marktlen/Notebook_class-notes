# 文件IO

- 文件基本操作，打开、定位、读写、关闭
  - fopen和open，C库fopen有功能扩展

- IO效率

- 文件共享(必考)

- 其他重要IO函数

## 文件操作基本顺序

- 打开 open

- 创建 creat

- 定位 lseek

- 读 read

- 写 write

- 关闭 close

### 打开 open

用于打开或者创建一个文件

函数原型

```c
#include<fcntl.h>
int open(const char* pathname, int oflag, ...)
    //打开或创建的文件名，用于指定文件打开模式、标志等信息
    //需要前赋予文件权限，Linux的9个权限
```

#### oflag

- Linux头文件已经为文件打开模式、标志等定义了若干的宏

- oflag需要指定这些宏

- 宏定义在/usr/include/bits/fcntl.h中

- 在该头文件中，只读打开标志被定义为

- #define O_RDONLY  00

- 文件打开模式标志

  ​	以下三个标志必须指定一个且只能指定一个

  - O_RDONLY ： 只读打开

  - O_WRONLY ： 只写打开

  - O_RDWR   ： 读写打开

- 其他文件标志

   下面的标志是可以选择的，可通过C语言的或运算与文件打开标志进行组合

  - O_APPEND：每次写的数据都添加到文件尾

  - O_TRUNC：若此文件存在，并以(权限)读写或只写打开，则文件长度为0

  - O_CREAT：若文件不存在，则创建该文件。此时，open函数需要第三个参数，用于指定该文件的访问权限位

  - O_EXCL：若同时指定了O_CREAT标志，而文件已经存在，则会出错。可用于测试文件是否存在

返回值

- 整数数据
  - 成功时，返回文件描述符
  - 出错时，返回-1

文件描述符

- Window时返回文件句柄，是同一个描述
- 文件描述符：已打开文件的索引-->通过通过索引找到已打开文件

#### 进程打开文件的内核数据结构

![进程打开文件](img\进程打开文件.png)

子进程会复制父进程fd_arrag数组

VFS抽象文件系统，方便文件系统与系统进行对接。

task-struct的files可以但不一定共用，不一定每一个进程有files_struct甚至会共享

从fd数组（已打开文件表）里面找到一个没有表项的数组项

读取文件描述符，找到PCB，取出已打开文件表files，读出file结构体

找到dentry（目录项）找到inode(索引节点)

file里面的flag是两个字段，存放open时的标志

进程创建时，创建了task_strct和files_struct的链接

##### 索引节点

- 文件系统索引节点的信息，存储在磁盘上
- 当需要时，调入内存，填写VFS的索引节点（即inode结构）
- 每个文件都对应了一个索引节点
- 通过索引节点号，可以唯一的标识文件系统中的指定文件

```c
struct inode{
    //...
    unsigned long i_no;	// 索引节点号
    umode_t i_mode;	// 文件类型访问
    uid_t i_uid;	//文件拥有者ID
    gid_t i_gid;	//文件拥有者所在组ID
    off_t i_size;	//文件大小
    time_t i_atime;	//文件最后访问时间
    time_t i_mtime;	//文件最后修改时间
};
```

元数据：描述性数据

##### 文件描述符

open函数返回的文件描述符已打开文件表的索引

文件描述符是已打开文件的索引，通过该值可以在fd_array表中检索相应的文件对象

文件描述符是一个非负的整数

文件描述符0、1、2分别对应于标准输入、标准输出、标准出错，在进程创建时，已经打开。

#### 程序演示 open函数

出错处理(2.1)

errno.h头文件中，定义了errno：当API调用出错时，errno说明出错的具体原因

可简单地将errno理解成整型数据

出错信息转换成可读字符串

```c
#include<string.h>
char* strerror(int errno);
```

示例2.2

```c
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <iostream>

using namespace std;

int main()
{
  int fd = open("a.txt", O_RDONLY);
  if(-1 == fd)
  {     
    cout << "open error" << endl;
    cout << strerror(errno) << endl;
  }
  
  return 0;
}
```

以前的定义：extern int errno;

多线程环境：

```c
extern int * __errno_location();
#define errno (*__errno_location())
#Win: GetLastError()
```

perror函数

- perror函数根据当前的errno，输出一条出错信息

函数原型

```c
#include<stdio.h>
void perror(const char* msg);
```

示例2.3

```c
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <iostream>

using namespace std;

int main()
{
  int fd = open("a.txt", O_RDONLY);
  if(-1 == fd)
  {     
    cout << "open error" << endl;
    perror("test3");
  }
  
  return 0;
}

```

该函数输出：

msg指向的字符串: errno对应的出错信息

### 创建 creat

用于创建一个新文件

函数原型

```c
 int creat(const char *pathname, mode_t mode)
```

参数

- pathname：要创建的文件名（包括路径信息）

- mode：同open的第三个参数，讨论文件的访问权限位时分析

返回值

- 成功返回**只写打开**的文件描述符
- 出错返回-1

creat函数的功能可以用open函数实现

```c
 open(pathname,
 	O_WRONLY | O_CREAT | O_TRUNC,
	mode);
```

为什么需要指定O_TRUNC标志，覆盖已经存在的同名文件

当文件存在时，调用creat函数，会将文件的大小变为0

示例2.2

```c
#include<iostream>
#include<fcntl.h>
#include<unistd.h>
#include<sys/types.h>

using namespace std;

int main()
{    
  int fd = creat("a.txt", S_IRWXU);
    //S_IRWXU 所有者可读可写可执行
  return 0;
}
```

creat函数缺点：它以只写方式打开所创建的文件。若要创建一个临时文件，并先写该文件，然后又读该文件，则必须先调用creat，close，然后再open。简便方法：

```c
open(pathname,
	O_RDWR | O_CREAT | O_TRUNC, 
	mode);
```

### 定位 lseek

lseek函数用于修改当前文件偏移量

当前文件偏移量的作用
- 规定了从文件什么地方开始进行读、写操作

通常，读、写操作结束时，会使文件偏移量增加读写的字节数（一般文件顺序读写，自动调整偏移量，不需要手动调整）

当打开一个文件时，偏移量被设置为0

函数原型

```c
off_t lseek(int filedes,off_t offset,int whence)
```

参数

- 第一个参数filedes：open/creat函数返回的文件描述符

- 第二个参数offset：
  - 相对偏移量：需结合whence才能计算出真正的偏移量
  - 类型off_t：32位机是32位数据类型，64位是64位
- 第三个参数Whence：该参数取值是三个常量之一
  - SEEK_SET： 当前文件偏移量为：距文件开始处的offset个字节
  - SEEK_CUR： 当前文件偏移量为：当前文件偏移量＋offset(可正可负)
  - SEEK_END： 当前文件偏移量为：当前文件长度＋offset(可正可负)

返回值：

- 若成功，返回新的文件偏移量

- 若出错，返回-1

获得当前的偏移量

- off_t CurrentPosition;

- CurrentPosition = lseek(fd, 0, SEEK_CUR);

lseek操作并不引起任何I/O操作，只是修改内核中的记录（修改file结构体中的f_pos）

#### 空洞文件

使用lseek修改文件偏移量后，当前文件偏移量有可能大于文件的长度

在这种情况下，对该文件的下一次写操作，将加长该文件

这样文件中形成了一个空洞。对空洞区域进行读，均返回0

![文件空洞](img\文件空洞.png)

演示2.3

```c
#include <fcntl.h>
#include <iostream>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

using namespace std;

int main()
{
  int fd = creat("file.hole", S_IRWXU);
  if (-1 == fd)
  {
    cout << "creat error" << endl;
    return 0;
  }
  char buf[100];//模拟文件原本大小
  for (int i = 0; i < 100; i++)
    buf[i] = 'a';
  if (write(fd, buf, 100) != 100)
  {
    cout << "write 1 error" << endl;
    return 0;
  }
  //文件大小变成100字节
  if (lseek(fd, 50, SEEK_END) == -1)//模拟文件偏移，创建空洞
  {
    cout << "lseek error" << endl;
    return 0;
  }
  if (write(fd, buf, 50) != 50)//再写50个字节
  {
    cout << "write 2 error" << endl;
    return 0;
  }
  return 0;
}
```

这时文件大小变成了200字节

```bash
$ls -l
root 200 Mar 10 file.hole
$od -x file.hole
#*代表与上行相同，全部省略若干行
$od -A x -t x1 file.hole
#用od命令读文件二进制
```

如果偏移太大，大于每次分配磁盘块大小，就不占用磁盘空间。

### 读 read

用于从文件中读出数据

函数原型

```c
ssize_t read(int fd, void *buff, size_t nbytes)
```

参数

- 第一个参数fd：文件描述符

- 第二个参数buff：指向缓冲区，用于存放从文件读出的数据

- 第三个参数nbytes：unsigned int；需要从文件中读出的字节数
  - 缓冲区的大小>=nbytes

返回值

- 返回值类型： ssize_t，有符号的，32位机中32bits，64位机中64bits

- 出错：返回-1

- 成功：返回从文件中实际读到的字节数

- 当读到文件结尾时，则返回0

无符号数和有符号数比较，当出错时返回-1与需要读的字节数进行比较时，一定大于需要读字节数，容易判断错误。

很多情况下，read实际读出的字节数都小于要求读出的字节数

- 读普通文件，在读到要求的字节数之前，就到达了文件尾端

- 当从终端设备读时，通常一次最多读一行

- 当从网络读时，网络中的缓冲机构可能造成read函数返回值小于所要求读出的字节数

- 某些面向记录的设备，如磁带，一次最多返回一个记录
- 等

### 写 write

用于向文件里面，写入数据

函数原型

```c
ssize_t write(int fd, const void *buff, size_t nbytes);
```

参数

- 第一个参数fd：文件描述符

- 第二个参数buff：指向缓冲区，存放了需要写入文件的数据

- 第三个参数nbytes：需要写入文件的字节数

返回值

- 返回值类型： ssize_t，有符号的，在32位系统中是32bits，64位是64bits

- 出错：返回-1

- 成功：返回实际写入文件的字节数

write出错的原因

- 磁盘满

- 没有访问权限

- 超过了给定进程的文件长度限制

- 等

当从文件中间某处写入数据时，是插入操作？覆盖操作？还是不能写？（程序演示2.4）

```c
#include <fcntl.h>
#include <iostream>
#include <unistd.h>

using namespace std;

int main()
{
  int fd = open("a.c", O_RDWR);
  char buf = 'q';
  cout << write(fd, &buf, 1) << endl;
  return 0;
}
```

中间写入是**覆盖操作**

当以O_APPEND选项打开一个文件时，能否使用lseek指定文件偏移量？指定之后，从文件什么地方开始进行写？读操作又是如何？（程序演示2.5）

```c
#include <fcntl.h>
#include <iostream>
#include <unistd.h>

using namespace std;

int main()
{
  int fd = open("a.c", O_RDWR | O_APPEND);
  if (-1 == fd)
  {
    cout << "open error" << endl;
    return 0;
  }
  off_t CurrentPosition = lseek(fd, 0, SEEK_CUR);
  cout << "CurrentPosition:  " << CurrentPosition << endl;//当前文件偏移量 0

  char buf = 'm';
  if (write(fd, &buf, 1) == -1)
  {
    cout << "write error" << endl;
    close(fd);
    return 0;
  }
  CurrentPosition = lseek(fd, 0, SEEK_CUR);
  cout << "After writing m, CurrentPosition:  " << CurrentPosition << endl;//修改文件尾部的偏移量 22

  if (lseek(fd, 0, SEEK_SET) == -1)
  {
    cout << "lseek error" << endl;
    close(fd);
    return 0;
  }
  off_t NewCurrentPosition = lseek(fd, 0, SEEK_CUR);
  cout << "NewCurrentPosition:  " << NewCurrentPosition << endl;//文件还可以把偏移量修改到头部

  char buf1 = 'P';//如果修改成功，查看p的出现位置
  if (write(fd, &buf1, 1) == -1)
  {
    cout << "write error" << endl;
    close(fd);
    return 0;
  }
  close(fd);
  return 0;
}
```

只要使用O_APPEND无论lseek如何修改，总是出现在文件尾部，都是写到尾部

### 关闭 close

用于关闭一个已打开的文件

函数原型

```c
int close(int filedes)
```

返回值

- 成功返回0

- 出错返回-1

参数 filedes：文件描述符

引用计数为零时，会自动回收资源

当clsoe函数关闭文件时，会释放进程加在该文件上的所有记录锁

内核会对进程打开文件表、文件对象、索引节点表项等结构进行修改，释放相关的资源

当进程退出时，会关闭当前所有已打开的文件描述符

## IO效率

程序3.3

```c
#define BUFFSIZE 4096
int main()
{
  int n;
  char buf[BUFFSIZE];
	// 对标准输入和标准输出进行了重定向
	//从文件file1读数据
	//程序中，影响效率的关键：BUFFSIZE的取值
  while((n = read(STDIN_FILENO, buf, BUFFSIZE))>0)
       if(write(STDOUT_FILENO, buf, n)  != n)
                   err_sys(“write error”);
  return 0;
}
```

4KB，效率最高，缓存库处理

原因

- Linux文件系统采用了某种预读技术

- 当检测到正在进行顺序读取时，系统就试图读入比应用程序所要求的更多数据

- 并假设应用程序很快就会读这些数据

- 当BUFFSIZE增加到一定程度后，预读就停止了

启示：如何提高I/O效率

慢在哪里？

- 整个磁盘操作的过程是什么：寻道、旋转、读/写
  - 添加缓冲，数据放在连续的扇区，冗余磁盘阵列(RAID)

- 每调用一次read/write，就陷入一次内核

- SSD的情况

改进的思路

- 尽量使磁头顺序移动，如LSF 日志文件

- 利用缓存，减少磁盘I/O、read/write调用次数
  - 用户cache减少系统调用

- 有时轮询比中断好 如：NVME

## 文件共享:star:

### 不同进程打开不同的文件

互不干扰

### 不同进程打开同一个文件

![两个独立进程各自打开同一个文件](img\两个独立进程各自打开同一个文件.png)

进程B新建file不再寻找inode，直接用进程A找到的Inode。两个进程共享inode

每个进程都有自己的当前文件偏移量

在完成每个write后，当前文件偏移量即增加所写的字节数

如果用O_APPEND标志打开了一个文件，则该标志存储在file结构体中。每次执行写操作时，当前偏移量首先被设置为文件长度

### 父子进程共享文件对象的情况

当A--fork-->B会发生这种情况，处于浅拷贝

![不同进程共享文件对象](img\不同进程共享文件对象.png)

假设存在以下竞争情况

```c
//进程A
lseek(fd,50,SET);//当前偏移50，返回内核发生调度为B
Write(fd,buf,50);//在偏移为200时写入，发生输入位置偏移
//进程B
lseek(fd,200,SET);//2->5，设偏移200，再次发生调度
write(fd,buf,50);
```

存在模式转换的调度点，发生两个偏移量不一致，ACID（原子性，移植性，隔离性，持久性）

原子操作需要做事件操作

### 同一个进程打开不同的文件

### 同一个进程内的共享（dup等）

### 同一个进程内线程的共享



------

# 补充

**如何提升读取性能**

在cache的帮助下数组的读取5ns，cache会自动完成后面的读取，但链表无法完成。使用位向量减少内存表象，一个bit对应一个表象。

把Key/Value放同一个数组，可以用cache line提升访问速度。会直接命中

**Linux进程**

Linux中线程是一种进制，只是共用同一个页表

**TLS（Thread Local Storage）线程局部存储的实现**

第一种

​	假设最多支持8个线程。tid = GetTLS.TId()，no = tid %8

第二种

段基址+偏移量=线性地址

GS段和FS段的段基址不是零，每个线程都有自己的FS段

&errorno取地址操作取的是都是偏移量，除了GS段和FS段外

如：

​	T1 base = 1000 error:80

​	T2 base = 2000 error:80

​	T3 base = 3000 error:80

**内存泄漏**

分配了但想释放但是没办法释放（找不到，没引用）

**NVME**

AP经过PCIE访问SSD

物理页面可以被多个虚拟页面映射

为了让AP直接访问，减少线程内核开销，用轮询的方法提高了读写效率

**深浅拷贝**

浅拷贝：逐指针拷贝；深拷贝：指向的拷贝内容